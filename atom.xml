<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>葛布斯</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://NicholasYG.github.io/"/>
  <updated>2018-11-10T05:57:55.670Z</updated>
  <id>https://NicholasYG.github.io/</id>
  
  <author>
    <name>葛布斯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java注解的基本用法</title>
    <link href="https://NicholasYG.github.io/2018/11/09/Java/"/>
    <id>https://NicholasYG.github.io/2018/11/09/Java/</id>
    <published>2018-11-09T08:01:25.000Z</published>
    <updated>2018-11-10T05:57:55.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章讲述java中注解的概念和注解的基础用法，文章中举例用到的注解、元注解只是一部分，平时工作中用到过，有错误或新的见解，请指出。</p><h2 id="注解概念"><a href="#注解概念" class="headerlink" title="注解概念"></a>注解概念</h2><p>注解你可以理解为是某个类、某个方法的标签，有了这个标签(注解),就具备了某一个功能，举个例子，我们有一个类实现一个接口中的方法，在继承的方法上面都会有<code>@Override</code>的注解，就代表了这个方法是属于继承方法；或者在方法使用<code>@Deprecated</code>注解，就表示该方法已经过期，调用的时候方法上会有中划线的提示。以上例子只是标识注解，还有更多的带有成员或者自定义的注解，往下慢慢看来了解吧。</p><h2 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h2><ul><li>jdk中的注解</li></ul><blockquote><p>例：@Override、@Deprecated等</p></blockquote><ul><li>来自第三方的注解</li></ul><blockquote><p>例：Retrofit中的@GET、@POST，Spring中的@Autowired等</p></blockquote><ul><li>自定义注解</li></ul><blockquote><p>根据原则定义自己需求的注解</p></blockquote><p>上面说的三种注解的分类，jdk中的注解，需要我们去查看api文档，逐个了解，这里不多做赘述，第三方的注解，也是属于自定义注解，是一些优秀的框架中定义的注解，我们在平时的工作中会经常用到，举例的Retrofit是Android中应用非常广泛的网络框架；而spring则是java后台常用的。最后一个自定义注解，就是我们今天主要要了解和学习的，看看怎样去定义一个注解。</p><h3 id="自定义注解原则"><a href="#自定义注解原则" class="headerlink" title="自定义注解原则"></a>自定义注解原则</h3><ul><li><p>使用@interface关键字定义注解</p></li><li><p>成员以无参无异常的方式声明</p></li><li><p>可以用default为成员设置默认值</p></li><li><p>添加元注解(下面会做单独的介绍)</p></li><li><p>示例:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 元注解</span><br><span class="line"> */</span><br><span class="line">@Target(TYPE)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">//@interface关键字</span><br><span class="line">public @interface Description &#123;</span><br><span class="line"></span><br><span class="line">    String name();//无参数无异常的方法声明</span><br><span class="line">    String gender();</span><br><span class="line">    int age()default 18;//使用default字段设置默认值</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解中成员变量的规则要求"><a href="#注解中成员变量的规则要求" class="headerlink" title="注解中成员变量的规则要求"></a>注解中成员变量的规则要求</h3><ul><li><p>在注解中声明的成员变量是有类型限制的，合法的类型包括基本数据类型及String、Class、Annotation、Enumeration,一般我们常用到就是基本数据类型和String</p></li><li><p>如果注解中只有一个成员，则方法名必须要写成<code>value()</code>,在使用的时候就可以忽略掉方法名和赋值符号(就是=)</p></li></ul><p>示例：定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Target(TYPE)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">public @interface Description2 &#123;</span><br><span class="line">    //一个成员的定义 方法名为vaule</span><br><span class="line">    String value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在注解中可以没有成员，没有成员的注解称为标识注解，就类似于jdk中的<code>@Override、@Deprecated</code></li></ul><h3 id="元注解-注解的注解"><a href="#元注解-注解的注解" class="headerlink" title="元注解:注解的注解"></a>元注解:注解的注解</h3><p>我们看到在定义自定义注解的时候，上面定义了一些<code>@Target、@Inherited</code>等字段，它们有什么作用呢？看看下面的解释</p><h4 id="Target注解"><a href="#Target注解" class="headerlink" title="@Target注解"></a>@Target注解</h4><ul><li><p>Target注解可以规定在哪些地方使用</p></li><li><p>Target定义的成员类型是ElementType数组，Target中可以传入多个参数</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">public @interface Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数的类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//使用的jdk8中的ElementType 在8之前没有TYPE_PARAMETER和TYPE_USE两个参数值</span><br><span class="line"></span><br><span class="line">ANNOTATION_TYPE,//注释类声明</span><br><span class="line">CONSTRUCTOR,//构造方法声明</span><br><span class="line">FIELD,//字段声明</span><br><span class="line">LOCAL_VARIABLE,//局部变量声</span><br><span class="line">METHOD,//方法声明</span><br><span class="line">PACKAGE,//包声明</span><br><span class="line">PARAMETER,//参数声明</span><br><span class="line">TYPE,//类、接口声明</span><br><span class="line">TYPE_PARAMETER,//类型参数声明</span><br><span class="line">TYPE_USE;//没搞懂这个，官方API中给出的注释是Use of a type</span><br></pre></td></tr></table></figure><ul><li>示例：<code>@Target({METHOD,TYPE})</code>表示可以作用于方法、类、接口等</li></ul><h4 id="Retention注解"><a href="#Retention注解" class="headerlink" title="@Retention注解"></a>@Retention注解</h4><ul><li><p>Retention指的是该注解的生命周期</p></li><li><p>参数类型</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CLASS,//只在源码显示，编译时会丢失</span><br><span class="line">RUNTIME,//编译时会记录到class中，运行时忽略</span><br><span class="line">SOURCE;//运行时存在，可以通过反射获取</span><br></pre></td></tr></table></figure><h4 id="Inherited注解"><a href="#Inherited注解" class="headerlink" title="@Inherited注解"></a>@Inherited注解</h4><ul><li><p>Inherited表示允许子类继承</p></li><li><p>属于标识注解</p></li></ul><h4 id="Documented注解"><a href="#Documented注解" class="headerlink" title="@Documented注解"></a>@Documented注解</h4><ul><li><p>生成javadoc时会包含注解的信息</p></li><li><p>属于标识注解</p></li></ul><h3 id="自定义注解用法："><a href="#自定义注解用法：" class="headerlink" title="自定义注解用法："></a>自定义注解用法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//多个成员用法</span><br><span class="line"></span><br><span class="line">@Description(name = &quot;gdy&quot;,gender = &quot;man&quot;,age = 20)</span><br><span class="line">public String getName() &#123;</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br><span class="line">//只有一个成员定义</span><br><span class="line">@Description2(&quot;gdy&quot;)</span><br><span class="line">public String getAge() &#123;</span><br><span class="line">    return age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们就用一个简单的小demo来演示一下注解的具体使用</p><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><h4 id="定义只有一个成员的注解"><a href="#定义只有一个成员的注解" class="headerlink" title="定义只有一个成员的注解"></a>定义只有一个成员的注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">public @interface TestAnn &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//定义了一个接口</span><br><span class="line">public interface Person &#123;</span><br><span class="line">    String name();</span><br><span class="line">    String gender();</span><br><span class="line">    int age();</span><br><span class="line">&#125;</span><br><span class="line">//实现类中使用注解</span><br><span class="line">@TestAnn(&quot;我是一个person实现类&quot;)</span><br><span class="line">public class DuoDuo implements Person &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @TestAnn(&quot;我的名字叫多多&quot;)</span><br><span class="line">    public String name() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String gender() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int age() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在运行时解析注解"><a href="#在运行时解析注解" class="headerlink" title="在运行时解析注解"></a>在运行时解析注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class myClass &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //1、使用类加载器加载类</span><br><span class="line">            Class duo = Class.forName(&quot;com.rxjava.model.DuoDuo&quot;);</span><br><span class="line">            //2、找到类上面的注解 </span><br><span class="line">            boolean isExist = duo.isAnnotationPresent(TestAnn.class);</span><br><span class="line">            if (isExist) &#123;</span><br><span class="line">                //3、获取注解实例，并输出值</span><br><span class="line">                TestAnn t = (TestAnn) duo.getAnnotation(TestAnn.class);</span><br><span class="line">                System.out.println(t.value());</span><br><span class="line">            &#125;</span><br><span class="line">            //4、获取每个方法上的值</span><br><span class="line">            Method[] duoMethods = duo.getMethods();</span><br><span class="line">            for (Method duoM : duoMethods) &#123;</span><br><span class="line">                boolean isMExist = duoM.isAnnotationPresent(TestAnn.class);</span><br><span class="line">                if (isMExist) &#123;</span><br><span class="line">                    TestAnn tm = duoM.getAnnotation(TestAnn.class);</span><br><span class="line">                    System.out.println(tm.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="/2018/11/09/Java/print_out.jpg" alt="输出结果"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本篇文章是根据慕课网java注解完全解析，总结出来的笔记，想更细致的了解注解的使用，可移步到慕课网去观看视频，另外还有一篇大神讲解的深入简出、通俗易懂，也可一并观摩。</p><p><a href="https://www.imooc.com/learn/456" target="_blank" rel="noopener">慕课网篇</a></p><p><a href="https://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener">通俗易懂篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章讲述java中注解的概念和注解的基础用法，文章中举例用到的注解、元注解只是一部分，平时工作中用到过，有错误或新的见解，请指出。&lt;/p
      
    
    </summary>
    
      <category term="java" scheme="https://NicholasYG.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://NicholasYG.github.io/tags/java/"/>
    
      <category term="注解" scheme="https://NicholasYG.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Android微信支付</title>
    <link href="https://NicholasYG.github.io/2018/10/27/Android%E6%94%AF%E4%BB%98/"/>
    <id>https://NicholasYG.github.io/2018/10/27/Android支付/</id>
    <published>2018-10-27T02:29:56.000Z</published>
    <updated>2018-10-27T07:34:24.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集成步骤"><a href="#集成步骤" class="headerlink" title="集成步骤"></a>集成步骤</h2><h3 id="先贴上官方文档的集成步骤"><a href="#先贴上官方文档的集成步骤" class="headerlink" title="先贴上官方文档的集成步骤"></a>先贴上官方文档的集成步骤</h3><p><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419319167&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">资源链接</a><br>微信支付所需要的资源文件（包含支付demo和签名生成工具）</p><p><a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_5" target="_blank" rel="noopener">集成步骤链接</a><br>按照官方文档，一步一步集成下去，你会发现一个接一个-1等着你。</p><h3 id="导入依赖库（jar包）"><a href="#导入依赖库（jar包）" class="headerlink" title="导入依赖库（jar包）"></a>导入依赖库（jar包）</h3><ul><li>导入相关文件，在eclipse上是导入jar包，在AS环境中，可以再build.gradle文件中，添加如下依赖即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">//包含统计功能</span><br><span class="line">   compile &apos;com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+&apos;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">dependencies &#123;</span><br><span class="line">   compile &apos;com.tencent.mm.opensdk:wechat-sdk-android-without-mta:+&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当然也还可以用导入jar包的方式，下载demo文件，找到libammsdk.jar，导入到自己的项目libs文件夹中(解压压缩包，在libs文件夹中找到libammsdk.jar)</li></ul><p><img src="/2018/10/27/Android支付/source_link.jpg" alt="资源下载"></p><p>下载地址同上面的资源链接，之后同步工程，jar包导入工作就算完成了。</p><h3 id="添加WXPayEntryActivity文件（微信结果回调的类）"><a href="#添加WXPayEntryActivity文件（微信结果回调的类）" class="headerlink" title="添加WXPayEntryActivity文件（微信结果回调的类）"></a>添加WXPayEntryActivity文件（微信结果回调的类）</h3><p>WXPayEntryActivity是微信支付结果的回调类，调用微信支付SDK之后返回的结果，都会此类中获取到，根据集成要求，此类必须放在指定的位置。</p><p><img src="/2018/10/27/Android支付/file_catalog.jpg" alt="回调类的位置"></p><p>如上图WXPayEntryActivity必须放在这个路径下面（在Project目录结构下 <code>main</code>–<code>java</code>–<code>自己的包名</code>–<code>wxapi</code>–<code>WXPayEntryActivity</code>），如果集成过微信分享，放置的文件位置是一样的。<br>然后在清单文件(AndroidManifest)中加入WXPayEntryActivity的相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--微信支付--&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.wxapi.WXPayEntryActivity&quot;</span><br><span class="line">    android:exported=&quot;true&quot;</span><br><span class="line">    android:launchMode=&quot;singleTop&quot;</span><br><span class="line">    android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">        &lt;data android:scheme=&quot;you appid&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>看一下里面的内容</p><p><img src="/2018/10/27/Android支付/WXPayEntryActivity.jpg" alt="onCreat内容"></p><p>在onCreat方法中，有一个布局文件，你可以自定义，微信支付调起以后，你想展示怎样的界面，如何告知用户，都可以在WXPayEntryActivity中展示，当然，也可以注释掉，不使用任何布局，获取到支付结果后，做相应的处理就行。<br>下面是获取支付结果的方法：</p><p><img src="/2018/10/27/Android支付/pay_method.jpg" alt="支付结果返回码"></p><p>demo中给出的onResp方法，会将支付结果以弹窗的形式显示出来。当然你可以根据不同的状态码做不同的操作，<br>仅供参考（code 0、支付成功  -1、支付失败  -2、取消支付）</p><p><img src="/2018/10/27/Android支付/code_state.jpg" alt="状态处理"></p><p>你可以根据不同的状态做相应的处理，文档也对三种状态有对应的解释：</p><p><img src="/2018/10/27/Android支付/error_code.jpg" alt="文档code说明"></p><p>其中支付失败，返回-1的场景有很多，后面再详细说明。</p><h3 id="调用微信支付"><a href="#调用微信支付" class="headerlink" title="调用微信支付"></a>调用微信支付</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void toWeChatPay(OrderModel orderModel) &#123;</span><br><span class="line">     IWXAPI wxapi = WXAPIFactory.createWXAPI(this, Const.WECHAT_PAY_APP_ID);    </span><br><span class="line">    if (wxapi.isWXAppInstalled()) &#123;//判断是否安装微信</span><br><span class="line">    wxapi.registerApp(Const.WECHAT_PAY_APP_ID);//把app注册到微信</span><br><span class="line">        //给PayReq赋值</span><br><span class="line">        PayReq req = new PayReq();</span><br><span class="line">        req.appId = Const.WECHAT_PAY_APP_ID;</span><br><span class="line">        req.partnerId = orderModel.partnerId;</span><br><span class="line">        req.prepayId = orderModel.prepayId;</span><br><span class="line">        req.packageValue = orderModel.packageValue;</span><br><span class="line">        req.nonceStr = orderModel.nonceStr;</span><br><span class="line">        req.timeStamp = orderModel.timeStamp;</span><br><span class="line">        req.sign = orderModel.sign;</span><br><span class="line">        //发起请求 调用微信支付</span><br><span class="line">        wxapi.sendReq(req);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ToastUtil.showToast(activity, &quot;请您先安装微信！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时的七个参数，可以查看具体的<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_12" target="_blank" rel="noopener">文档说明</a></p><p><img src="/2018/10/27/Android支付/parameter.jpg" alt="参数"></p><p>这些个参数，可以跟后台沟通，返回给我们使用，当然其中的appid可以定义成静态的全局变量,在使用之前最好做一下非空判断。</p><h3 id="调用返回-1分析"><a href="#调用返回-1分析" class="headerlink" title="调用返回-1分析"></a>调用返回-1分析</h3><p>以上步骤如果你已经全部完成，那么恭喜你集成算是成功了，接下来将是调用迎来的errCode = -1，在文档上，对于-1的解释是这样的：</p><blockquote><p>可能的原因：签名错误、未注册APPID、项目设置APPID不正确、注册的APPID与设置的不匹配、其他异常等</p></blockquote><p>对以上提到的错误原因我们一一分析：</p><h4 id="首先说说签名错误"><a href="#首先说说签名错误" class="headerlink" title="首先说说签名错误"></a>首先说说签名错误</h4><p>签名如何获取？根据文档提供的下载链接，下载签名工具，输入包名，生成app唯一的签名，在文档上有详细的说明，但是要注意生成的签名，debug包和release包生成的签名是不一样的，所以在微信开放平台中填写的签名一定要区分，在测试阶段使用的是debug包生成的签名，上线使用的必须是release包生成的签名，一句话，应用包和签名一致，如果签名不一致，就会造成支付失败，errCode返回-1的情况。如果集成的有微信分享，可以用微信分享验证签名是否正确，如果同一签名下，微信分享可以分享成功，那么微信支付的签名一定是对的，返回-1就从其他方面找原因。</p><h4 id="APPID错误"><a href="#APPID错误" class="headerlink" title="APPID错误"></a>APPID错误</h4><p> APPID是微信开放平台给应用分配的，从上面复制就行，可以把APPID放在本地（一般不会变的），在AndroidManifast中、调用微信支付、WXPayEntryActivity等都会用到APPID。</p><h4 id="参数错误"><a href="#参数错误" class="headerlink" title="参数错误"></a>参数错误</h4><p>APPID和签名都正确的情况，再去调用微信支付。可能会出现这样的情况：如果微信未登录的情况下，会把微信调起来，在登录的情况下，返回值还是-1，这时候就要考虑参数的问题了，从demo里面拿过来的appid和一系列参数，放到自己的项目里面是不行的，参数要使用自己的appid对应生成的参数才可以，调用起微信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;集成步骤&quot;&gt;&lt;a href=&quot;#集成步骤&quot; class=&quot;headerlink&quot; title=&quot;集成步骤&quot;&gt;&lt;/a&gt;集成步骤&lt;/h2&gt;&lt;h3 id=&quot;先贴上官方文档的集成步骤&quot;&gt;&lt;a href=&quot;#先贴上官方文档的集成步骤&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Android" scheme="https://NicholasYG.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://NicholasYG.github.io/tags/Android/"/>
    
      <category term="支付" scheme="https://NicholasYG.github.io/tags/%E6%94%AF%E4%BB%98/"/>
    
      <category term="微信" scheme="https://NicholasYG.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用AS上传lib(module)包到Nexus私服（3.x）</title>
    <link href="https://NicholasYG.github.io/2018/10/16/Nexus%E7%A7%81%E6%9C%8D%E4%B8%8A%E4%BC%A0/"/>
    <id>https://NicholasYG.github.io/2018/10/16/Nexus私服上传/</id>
    <published>2018-10-16T11:41:02.000Z</published>
    <updated>2018-10-16T12:12:19.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="本篇文章要解决的问题如下"><a href="#本篇文章要解决的问题如下" class="headerlink" title="本篇文章要解决的问题如下"></a>本篇文章要解决的问题如下</h3><ul><li>搭建nexus私服</li><li>在nexus上创建仓库</li><li>配置grald文件，上传lib(module)包</li><li>在AS中使用</li></ul><p>本篇文章是基于Mac系统的基础上，搭建nexus；和windows系统搭建稍有差异。另本版本是基于nexus3.13.0版本，请知晓。</p><h2 id="nexus服务器搭建"><a href="#nexus服务器搭建" class="headerlink" title="nexus服务器搭建"></a>nexus服务器搭建</h2><h3 id="java环境"><a href="#java环境" class="headerlink" title="java环境"></a>java环境</h3><p>此版本的nexus是基于java，要求java JRE的版本不低于1.8.0，所以安装之前，先检测自己本地安装的JRE版本是否符合要求。</p><ul><li>检测当前java版本命令，在终端输入<br><code>java -version</code></li></ul><p><img src="/2018/10/16/Nexus私服上传/jave_version.jpg" alt="版本图片"><br>如上图，版本在1.8以上就可以下载nexus啦。</p><h3 id="下载nexus"><a href="#下载nexus" class="headerlink" title="下载nexus"></a>下载nexus</h3><p>可以在<a href="https://www.sonatype.com/download-oss-sonatype" target="_blank" rel="noopener">官方网站</a>下载最新版本的nexus，选择OS X版本</p><p><img src="/2018/10/16/Nexus私服上传/download_nexus.jpg" alt="下载截图"></p><p>下载完成后，打开解压包，会看到如下的目录</p><p><img src="/2018/10/16/Nexus私服上传/nexus_bin.jpg" alt="nexus文件目录"></p><p>接着在终端进入到bin目录下，输入命令 <code>nexus start</code> 看到 Starting nexus 字样就说明启动成功了</p><p><img src="/2018/10/16/Nexus私服上传/nexus_start.jpg" alt="开启nexus"></p><h2 id="在nexus上创建私有仓库"><a href="#在nexus上创建私有仓库" class="headerlink" title="在nexus上创建私有仓库"></a>在nexus上创建私有仓库</h2><h3 id="访问nexus和界面介绍"><a href="#访问nexus和界面介绍" class="headerlink" title="访问nexus和界面介绍"></a>访问nexus和界面介绍</h3><p>在本地浏览器输入<code>http://localhost:8081/</code> 跳转到nexus首页</p><p><img src="/2018/10/16/Nexus私服上传/nexus_index_page.jpg" alt="nexus首页"></p><p>在<code>Sign in</code>登录入口登录账号，nexus提供了一个公用账号 账号：admin 密码：admin123,登录上之后点击下图中第一步进入到设置界面，如下：</p><p><img src="/2018/10/16/Nexus私服上传/repository_page.jpg" alt="nexus首页"></p><p>点击第二步跳转到创建仓库界面。</p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>跳转到创建仓库界面，如下图</p><p><img src="/2018/10/16/Nexus私服上传/repository_list_default.jpg" alt="仓库列表界面"></p><p>可以看到nexus为我们创建了默认的仓库，在type列有<code>proxy、group、hosted</code>等类型，这三种类型都有什么作用呢？且看下面的解释：</p><ul><li>proxy（远程代理仓库）</li></ul><blockquote><p>这种类型的仓库，可以设置一个远程仓库的链接。当用户向 proxy 类型仓库请求下载一个依赖构件时，就会先在自己的库里查找，如果找不到的话，就会从设置的远程仓库下载到自己的库里，然后返回给用户，相当于起到一个中转的作用。例如 maven-central 用来存储从 Maven 中央仓库下载过的构件。</p></blockquote><ul><li>group （聚合仓库）</li></ul><blockquote><p>在 Maven 里没有这个概念，是 Nexus 特有的。目的是将多个仓库聚合，对用户暴露统一的地址，这样用户就不需要配置多个地址，只要统一配置 group 的地址就可以了。group 仓库的聚合成员可以在仓库设置中添加和移除。例如 maven-public 是一个 group 类型的仓库，通过引用这个地址，可以访问组内成员仓库的所有构件。</p></blockquote><ul><li>hosted（宿主仓库）</li></ul><blockquote><p>我们自己的构件，上传的就是这样的仓库。目前 maven-releases 和 maven-snapshots 是 hosted 类型的仓库。我们可以上传到这两个仓库，也可以自己创建 hosted 仓库。</p></blockquote><p>接着点击<code>Create Repositories</code>按钮，跳转到选择仓库界面，选择<code>maven2（hosted）</code>仓库</p><p><img src="/2018/10/16/Nexus私服上传/select_page.jpg" alt="选择仓库界面"></p><p>接下来是仓库的配置，可以根据自己的需求来修改</p><p><img src="/2018/10/16/Nexus私服上传/repository_detail.jpg" alt="配置详情页"></p><p>对于上面Maven2中Version policy的配置，官方是这样解释的:</p><ul><li>Release</li></ul><blockquote><p>可以将Maven存储库配置为适用于发布版本策略的发布组件。中央存储库使用发布版本策略</p></blockquote><ul><li>Snapshot</li></ul><blockquote><p>持续开发通常使用快照版本策略支持的快照版本执行。这些版本值必须以POM文件中的-SNAPSHOT结尾。这允许重复上传，其中实际使用的数字由日期/时间戳和枚举数组成，而且检索仍然可以使用-SNAPSHOT版本字符串。存储库管理器和客户机工具管理从快照版本到时间戳值的转换的元数据文件。</p></blockquote><ul><li>Mixed</li></ul><blockquote><p>混合版本策略允许您在一个存储库中支持这两种方法。</p></blockquote><p>附上<a href="https://help.sonatype.com/repomanager3/maven-repositories" target="_blank" rel="noopener">官方文档</a>，可以去看其他的配置解释。</p><p>点击保存，仓库就创建好了。回到首页，选择Browse，就可以看到我们刚才创建的仓库</p><p><img src="/2018/10/16/Nexus私服上传/new_repository.jpg" alt="新创建仓库"></p><p>点击列表中的<code>Copy</code>按钮，从弹框中获取到仓库地址，暂时保存待会儿会用到。</p><h2 id="创建lib（module）包，通过gradle上传"><a href="#创建lib（module）包，通过gradle上传" class="headerlink" title="创建lib（module）包，通过gradle上传"></a>创建lib（module）包，通过gradle上传</h2><h3 id="新建lib（module）包"><a href="#新建lib（module）包" class="headerlink" title="新建lib（module）包"></a>新建lib（module）包</h3><p>打开Android Studio在项目中创建lib包，选择Android Library；具体步骤如下：<br>在项目上右键，选择<code>new</code> –&gt; <code>Module</code> –&gt; <code>选择Android library</code></p><p><img src="/2018/10/16/Nexus私服上传/new_lib.jpg" alt="新建lib"></p><p>接着next下一步就可以了</p><p><img src="/2018/10/16/Nexus私服上传/select_android.jpg" alt="选择Android类型"></p><p>在lib（module）中写自己想要上传的内容，简单写一个类一个方法可以在后面调用就可以。</p><h3 id="配置gradle文件"><a href="#配置gradle文件" class="headerlink" title="配置gradle文件"></a>配置gradle文件</h3><p>内容补充完成后，需要在自己创建的lib（module）包的<code>build.gradle</code>文件中添加上传的代码，代码内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;maven&apos;</span><br><span class="line">task androidSourcesJar(type: Jar) &#123;</span><br><span class="line">    classifier = &apos;sources&apos;</span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">&#125;</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives androidSourcesJar</span><br><span class="line">&#125;</span><br><span class="line">afterEvaluate &#123; project -&gt;</span><br><span class="line">    uploadArchives &#123;</span><br><span class="line">        repositories &#123;</span><br><span class="line">            mavenDeployer &#123;</span><br><span class="line">                    //远程仓库的地址</span><br><span class="line">                repository(url: &quot;http://localhost:8081/repository/TestRepositoris/&quot;) &#123;</span><br><span class="line">                    //nexus登录的用户名和密码</span><br><span class="line">                    authentication(userName: &quot;admin&quot;, password: &quot;admin123&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                pom.project &#123;</span><br><span class="line">                    /**</span><br><span class="line">                     * 这三个字段是组成后续引用的关键，举例：</span><br><span class="line">                     * 之后在项目中会这样引用</span><br><span class="line">                     * com.xxx:testlibrary:1.0.0</span><br><span class="line">                     */</span><br><span class="line">                    groupId &apos;com.xxx&apos;</span><br><span class="line">                    artifactId &apos;testlibrary&apos;</span><br><span class="line">                    version &apos;1.0.0&apos;//版本号 </span><br><span class="line">                    packaging &apos;aar&apos;//打包的格式</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为方便配置也可以将上述代码新建一个gradle上传文件，在lib的build.gradle文件中来引用，具体操作：在lib(module)包上右键 –&gt; <code>New</code> –&gt; <code>File</code>；</p><p><img src="/2018/10/16/Nexus私服上传/new_gradle.jpg" alt="创建gradle文件"></p><p>之后创建.gradle为后缀名的文件</p><p><img src="/2018/10/16/Nexus私服上传/file_gradle.jpg" alt="gradle文件"></p><p>将上面配置代码复制进去,接着打开lib(module)包的<code>build.gradle</code>文件，引入新建的gradle文件，在上面添加<code>apply from: &#39;./upload.gradle&#39;</code> upload.gradle指的就是你创建的gradle文件，引入到build.gradle文件中使用</p><p><img src="/2018/10/16/Nexus私服上传/quote_file.jpg" alt="引入文件"></p><p>最后还需要在项目根目录的build.gradle文件中添加我们的仓库地址</p><p><img src="/2018/10/16/Nexus私服上传/project_gradle.jpg" alt="项目的gradle"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:3.0.1&apos;</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line">        //对maven插件进行修改可以兼容android</span><br><span class="line">        classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.5&apos;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven&#123;//仓库的地址</span><br><span class="line">            url &apos;http://localhost:8081/repository/TestRepositoris/&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步一下文件，AS会把我们的lib(module)生成要上传的文件。</p><h3 id="上传lib-module-包到nexus私服"><a href="#上传lib-module-包到nexus私服" class="headerlink" title="上传lib(module)包到nexus私服"></a>上传lib(module)包到nexus私服</h3><p>在AS编辑器的右侧工具栏，点击Gradle –&gt; 选择自己的项目 –&gt; 点击upload文件 –&gt; 双击uploadArchives</p><p><img src="/2018/10/16/Nexus私服上传/upload_lib.jpg" alt="上传lib包"></p><p>等待上传完成之后，就可以去私服上查看啦。点击自己创建的仓库查看：</p><p><img src="/2018/10/16/Nexus私服上传/upload_list_brower.jpg" alt="浏览器列表"></p><p>切换视图，网页版的展示</p><p><img src="/2018/10/16/Nexus私服上传/upload_list_html.jpg" alt="html浏览"></p><p>至此上传部分的工作已经完成；接下来就是在项目使用了。</p><h2 id="在AS中使用仓库中的lib"><a href="#在AS中使用仓库中的lib" class="headerlink" title="在AS中使用仓库中的lib"></a>在AS中使用仓库中的lib</h2><h3 id="在项目中引用"><a href="#在项目中引用" class="headerlink" title="在项目中引用"></a>在项目中引用</h3><ul><li>复制仓库的地址，放置在你想要引用项目的根目录的<code>build.gradle</code>中。注意：这里的项目是放置另外一个项目中，和lib包不是在同一个项目</li></ul><p><img src="/2018/10/16/Nexus私服上传/quote_project_gradle.jpg" alt="新项目中的引用"></p><ul><li>然后在app的<code>build.gradle</code>中加入<code>compile &#39;com.test:testlibrary:1.0.0&#39;</code></li></ul><p><img src="/2018/10/16/Nexus私服上传/quote_app_grade.jpg" alt="app的gradle中"></p><p>同步一下，就可以在代码中愉快的使用了，我是在lib包中放了一些关于缓存的代码，在项目中使用：</p><p><img src="/2018/10/16/Nexus私服上传/user_code.jpg" alt="代码中使用"></p><p>点击进去查看ACache文件，可以看到路径</p><p><img src="/2018/10/16/Nexus私服上传/lib_path.jpg" alt="路径"></p><p>到这里整个建库、上传、使用整个流程都完成了。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>第一次写公开式博客，历时2天，中间写写停停，还好最后算是勉强完成；之前自己有想记录的东西，都是以笔记的形式记录下来，很是粗糙，自己能看懂就行，不够细致，这篇写下来感觉真的很能加强知识点深度，强迫自己看了平时不愿看的英文文档，还写了迟迟不肯动手的demo，当写完的那一刻有一种酣畅淋漓的舒爽。第一次写还有许多不足的地方，会不断去完善，去修正编写的方式。坚持写下去，做一个深入简出的讲述者。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>写这篇博客参考了几位前辈的博客，在这里贴上链接，他们写的都很好，很值得借鉴和学习。</p><p><a href="https://blog.csdn.net/qq_32452623/article/details/79385595" target="_blank" rel="noopener">Android-Nexus 搭建自己的 Maven 仓库 &amp; Gradle 上传依赖包</a></p><p><a href="https://www.cnblogs.com/whoislcj/p/6490120.html" target="_blank" rel="noopener">Android业务组件化之Gradle和Sonatype Nexus搭建私有maven仓库</a></p><p><a href="https://www.jianshu.com/p/348cdc711c00" target="_blank" rel="noopener">Android依赖管理与私服搭建</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;本篇文章要解决的问题如下&quot;&gt;&lt;a href=&quot;#本篇文章要解决的问题如下&quot; class=&quot;headerlink&quot; title=&quot;本
      
    
    </summary>
    
      <category term="java" scheme="https://NicholasYG.github.io/categories/java/"/>
    
    
      <category term="Android" scheme="https://NicholasYG.github.io/tags/Android/"/>
    
      <category term="java" scheme="https://NicholasYG.github.io/tags/java/"/>
    
      <category term="nexus" scheme="https://NicholasYG.github.io/tags/nexus/"/>
    
  </entry>
  
</feed>
