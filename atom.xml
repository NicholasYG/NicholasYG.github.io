<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>葛布斯</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://NicholasYG.github.io/"/>
  <updated>2020-03-02T13:01:54.330Z</updated>
  <id>https://NicholasYG.github.io/</id>
  
  <author>
    <name>葛布斯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生成Android单元测试代码覆盖率报告的两种方式</title>
    <link href="https://NicholasYG.github.io/2020/03/02/jacoco%E4%BD%BF%E7%94%A8/"/>
    <id>https://NicholasYG.github.io/2020/03/02/jacoco使用/</id>
    <published>2020-03-02T06:34:23.416Z</published>
    <updated>2020-03-02T13:01:54.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章主要介绍在写完单元测试后，如何测试代码的覆盖率，从而更好的查缺补漏。下面我会介绍两种查看覆盖率的方法；一种是借助<code>Jacoco</code>，通过<code>Gradle</code>生成html报告。另一种是使用Android Studio自带的<code>Coverage</code>，在运行后展示在<code>Coverage</code>列表中，再根据需求导出即可。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>配置信息</li><li>使用Jacoco查看代码覆盖率</li><li>使用AS自带Coverage查看代码覆盖率</li><li>参考</li></ul><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><p>在测试前先说一下，现在用的各种包的版本和AS版本</p><ul><li>Android Studio 3.5.2</li><li>SDK 28</li><li>Gradle 3.4.2</li><li>Java JRE 1.8.0</li><li>Jacoco 0.8.5</li></ul><p>因为版本的不同，在配置上或界面上的展示效果也不尽相同，接下来我们进入正题，开始代码覆盖率的查看。</p><h2 id="使用Jacoco查看代码覆盖率"><a href="#使用Jacoco查看代码覆盖率" class="headerlink" title="使用Jacoco查看代码覆盖率"></a>使用Jacoco查看代码覆盖率</h2><h3 id="添加Jacoco-gradle文件"><a href="#添加Jacoco-gradle文件" class="headerlink" title="添加Jacoco.gradle文件"></a>添加<code>Jacoco.gradle</code>文件</h3><p><code>Jacoco.gradle</code>文件默认不会自动生成需要自己手动添加，添加的位置和你要测试Moudle或者Lib包中的<code>build.gradle</code>文件在同一层级：</p><p><img src="/2020/03/02/jacoco使用/add_jacoco.png" alt="放置位置"></p><p>创建好文件后，在文件中添加内容，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;jacoco&apos;</span><br><span class="line"></span><br><span class="line">jacoco &#123;</span><br><span class="line">    toolVersion = &quot;0.8.5&quot; //指定jacoco的版本</span><br><span class="line">    reportsDir = file(&quot;$buildDir/JacocoReport&quot;) //指定jacoco生成报告的文件夹</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType(Test) &#123;</span><br><span class="line">    jacoco.includeNoLocationClasses = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            //打开覆盖率统计开关</span><br><span class="line">            testCoverageEnabled = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//依赖于testDebugUnitTest任务</span><br><span class="line">task jacocoTestReport(type: JacocoReport, dependsOn: &apos;testDebugUnitTest&apos;) &#123;</span><br><span class="line">    group = &quot;reporting&quot; //指定task的分组</span><br><span class="line">    reports &#123;</span><br><span class="line">        xml.enabled = true //开启xml报告</span><br><span class="line">        html.enabled = true //开启html报告</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    def debugTree = fileTree(dir: &quot;$&#123;buildDir&#125;/intermediates/javac/debug/compileDebugJavaWithJavac/classes/你的包名&quot;, //指定类文件夹 包名以 / 分割</span><br><span class="line">            includes: [&quot;**/*.*&quot;], //包含类的规则,这里我们生成所有类的测试报告</span><br><span class="line">            excludes: [&apos;**/R.class&apos;,</span><br><span class="line">                       &apos;**/R$*.class&apos;,</span><br><span class="line">                       &apos;**/BuildConfig.*&apos;,</span><br><span class="line">                       &apos;**/Manifest*.*&apos;]) //排除类的规则</span><br><span class="line">            </span><br><span class="line">    def mainSrc = &quot;$&#123;project.projectDir&#125;/src/main/java&quot; //指定源码目录</span><br><span class="line"></span><br><span class="line">    sourceDirectories = files([mainSrc])</span><br><span class="line">    classDirectories = files([debugTree])</span><br><span class="line">    executionData = files(&quot;$&#123;buildDir&#125;/jacoco/testDebugUnitTest.exec&quot;) //指定报告数据的路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>jacoco.gradle</code>文件中的内容都有注释说明，重点说一下<code>def debugTree</code>选项</p><p><img src="/2020/03/02/jacoco使用/def_debuTree.png" alt="def debugTree"></p><p>这里指定的类文件夹，在<code>../classes/你的包名</code>后面写的就是你的包名，比如你的包名叫：</p><p><code>com.app.unit.test</code></p><p>那么在指定类文件夹这一项就这样写：</p><p><img src="/2020/03/02/jacoco使用/def_debuTree_pakeage.png" alt="def debugTree"></p><p>在配置里面说过当前使用的<code>gradle</code>是<code>3.4.2</code>，在<code>gradle3.x</code>之后<code>class</code>文件的目录是上面的：</p><p><code>/intermediates/javac/debug/compileDebugJavaWithJavac/classes/</code></p><p>如果你的<code>gradle</code>版本在<code>3.x</code>之前<code>class</code>文件目录需要替换成为：</p><p><code>/intermediates/classes/debug</code></p><p>两者对比写法：</p><p><img src="/2020/03/02/jacoco使用/def_debuTree_3.x.png" alt="3.x前后对比"></p><p>再有就是下面<code>includes</code>和<code>excludes</code>标签，前者是代表要测试哪些类，后者代表忽略哪些类，两者都可以指定多个文件，目前我没有找到忽略某个文件夹的方法，如果谁知道，可以跟我说一下。</p><h3 id="使用Jacoco进行测试"><a href="#使用Jacoco进行测试" class="headerlink" title="使用Jacoco进行测试"></a>使用<code>Jacoco</code>进行测试</h3><p><code>jacoco.gradle</code>文件配置好以后，我们需要项目的<code>buidle.gradle</code>中引用，这里的<code>buidle.gradle</code>就是和<code>jacoco.gradle</code>同一层级的文件，引用方式如下：</p><p><code>apply from: &#39;jacoco.gradle&#39;</code></p><p>把上面代码加入到<code>buidle.gradle</code>文件中，放置在最外层（第一行或第二行）。</p><p><img src="/2020/03/02/jacoco使用/apply_jacoco.png" alt="引用jacoco"></p><p>接着同步一下项目，我们就可以开始运行查看了。</p><h4 id="运行jacoco"><a href="#运行jacoco" class="headerlink" title="运行jacoco"></a>运行jacoco</h4><p>点击<code>AS</code>右侧的<code>gradle</code>工具栏</p><p><img src="/2020/03/02/jacoco使用/gradle_tool_1.png" alt="右侧gradle工具栏"></p><p>如果你在你的<code>AS</code>右侧没有看到<code>gradle</code>的标签，可以从<code>AS</code>上方的菜单栏进入：</p><p><code>View -- Tool Windows -- Gradle</code></p><p><img src="/2020/03/02/jacoco使用/gradle_tool_2.png" alt="view方式进入"></p><p>打开<code>gradle</code>后，找到其中的两个命令<code>testDebugUintTest</code>和<code>jacocoTestReport</code></p><p><img src="/2020/03/02/jacoco使用/two_command.png" alt="两个命令"></p><p>首先<code>双击</code>运行<code>testDebugUintTest</code>命令，之后在<code>AS</code>底部<code>Run</code>标签中可以看到，项目中所有的用例在运行，有错误会在列表中展示，最后测试多少用例，成功多少，失败多少，都会显示出来，我们可以根据提示进行修改，直到没有错误：</p><p><img src="/2020/03/02/jacoco使用/run_failed.png" alt="Run错误"></p><p>上图是双击后测试的结果，我们可以看到哪些测试用例出现了错误，而且给出错误提示。</p><p><img src="/2020/03/02/jacoco使用/run_success.png" alt="Run正确"></p><p>上图是经过改正后，所有的测试用例都通过了（有一个忽略的方法），这时我们的用例就跑完了。</p><p>接着我们<code>双击</code>运行<code>jacocoTestReport</code>命令，同样会在<code>Run</code>中展示，等运行完成，我们的报告也就生成了。</p><h4 id="查看报告"><a href="#查看报告" class="headerlink" title="查看报告"></a>查看报告</h4><p>刚才我们双击的<code>testDebugUintTest</code>命令，会生成单元测试的报告，而双击的<code>jacocoTestReport</code>命令会生成测试覆盖率报告，文件放置的位置在你测试的<code>Moudle</code>或<code>Lib</code>下的<code>build</code>文件夹下，报告在<code>reports</code>和<code>JacocoReports</code>中：</p><p><img src="/2020/03/02/jacoco使用/reports_path.png" alt="报告路径"></p><p>用浏览器分别打开<code>index.xml</code>文件可以看到详细的报告。</p><p>测试报告：</p><p><img src="/2020/03/02/jacoco使用/test_reports.png" alt="测试报告"></p><p>覆盖率报告：</p><p><img src="/2020/03/02/jacoco使用/test_coverage_reports.png" alt="覆盖率报告"></p><p>点击每项可以查看具体的测试情况，绿色代表已经测试部分，红色代表未测试到的部分，黄色代表部分执行，就像if else中的部分代码被执行。</p><p><img src="/2020/03/02/jacoco使用/color_detial.png" alt="覆盖率报告"></p><p>至此关于<code>Jacoco</code>覆盖率的相关介绍就结束了。</p><h2 id="使用AS自带Coverage查看代码覆盖率"><a href="#使用AS自带Coverage查看代码覆盖率" class="headerlink" title="使用AS自带Coverage查看代码覆盖率"></a>使用AS自带Coverage查看代码覆盖率</h2><p>除了<code>jacoco</code>三方库可以测试代码覆盖率外，<code>AS</code>自身也带有一种测试代码覆盖率的工具，下面我们就来介绍一下。</p><p>我们在运行测试类的时候，有两种方式；一种是在测试类中点击类名所在行的左侧，选择<code>Run xx.class</code>：</p><p><img src="/2020/03/02/jacoco使用/run_test_1.png" alt="运行测试类1"></p><p>或者是点击选中此类，右键，然后<code>Run xx.class</code>：</p><p><img src="/2020/03/02/jacoco使用/run_test_2.png" alt="运行测试类2"></p><p>上图可以看到箭头所指的就是我们运行测试类时，选择的方式。我们再看图中被圈住的命令</p><p><code>Run xx.class With Coverage</code></p><p>这一个命令，就是我们要说的另一种生成覆盖率报告的方式。</p><p>我们选择一个类，运行<code>Run xx.class With Coverage</code>命令，然后会出现下面的弹框：</p><p><img src="/2020/03/02/jacoco使用/add_dialog.png" alt="添加弹框"></p><p>我们选择中间的按钮<code>Add to active suites</code>，就会看到我们测试的类，添加到了<code>Coverage</code>工具栏的列表中，如下图所示：</p><p><img src="/2020/03/02/jacoco使用/coverage_list.png" alt="覆盖率列表"></p><p>我们看一下这个列表，在列表第一行可以看到<code>Element</code>、<code>Class</code>、<code>Method</code>、<code>Line</code>等选项（红框圈住的位置），它们分别代表的是<code>测试的类所在路径/包</code>、<code>此路径下类测试占比</code>、<code>方法数测试占比</code>、<code>代码测试的覆盖率</code>我们都可以看到，其中的<code>Line</code>就是我们需要的代码覆盖率。</p><p>可能你在点击按钮<code>Add to active suites</code>时，在<code>Coverage</code>工具栏的工具栏中并没有出现列表中的内容，而是显示一句话：</p><p><code>no coverage results. click Edit to fix configuration settings</code></p><p>解决方法是：我们点击界面上的<code>Edit</code>按钮，此时会跳转到<code>Edit configurations</code>界面，我们选择Junit测试选项，选中测试的类，在右侧选择<code>code coverage</code>标签，把下方的<code>Enable coverage in test folders</code>勾选上，别忘了最后点击<code>apply</code>按钮，操作步骤如下：</p><p><img src="/2020/03/02/jacoco使用/coverage_disable.png" alt="coverage不显示的情况"></p><p>选中之后，再重复上述操作，就可以在列表中看到覆盖率等内容了。</p><p>上面只说了看了一个测试文件的方式，如果想要看二个或者多个测试类的覆盖率的怎么做呢，只需要继续运行其他想看的类，选择<code>Add to active suites</code>按钮，测试的文件就添加到列表中了。</p><p>如果想要测试整个项目的代码覆盖率情况，我们可以点击<code>test</code>目录下<code>java</code>文件下项目包名，点击右键，选择<code>Run xx With Coverage</code>，具体操作如下：</p><p><img src="/2020/03/02/jacoco使用/project_test.png" alt="整个项目测试"></p><p>等测试用例运行完之后，接下来的操作和前面介绍的测试一个类的方式一样，只是这时候展示在列表中的文件有点多：</p><p><img src="/2020/03/02/jacoco使用/all_list.png" alt="完整目录列表"></p><p>我们从文件中顺着包名的顺序找到我们的测试文件，可以点进去看代码的覆盖率实际上这时我们可以在左侧的<code>Project</code>目录中看到，每个文件夹下的代码的测试覆盖率情况。</p><p><img src="/2020/03/02/jacoco使用/prject_check_coverage.png" alt="project看覆盖率"></p><p>点进测类的代码，在左侧也可以看到被测试到每一行代码都会有绿色的线条标注。</p><p><img src="/2020/03/02/jacoco使用/code_tag.png" alt="代码标记"></p><blockquote><p>注意：如果所有的类一起测试生成覆盖率报告，如果其中的某一个类没有测试通过，那么测试结果显示出的覆盖率为0%，遇到这种情况，我们只需将错误的位置修改后，单独运行，添加到列表中即可。</p></blockquote><p><img src="/2020/03/02/jacoco使用/coverage_faile.png" alt="覆盖率为0"></p><p>如果觉得这种查看的方式不爽，我们还可以生成像<code>jacoco</code>那样的html文件，方式也很简单。还是打开我们右侧的<code>Coverage</code>工具栏，在左侧我们看到有一排小的按钮，我们选择最下方的按钮：</p><p><img src="/2020/03/02/jacoco使用/export_button.png" alt="生成报告按钮"></p><p>在弹出的提示框中选择报告生成后放置的位置：</p><p><img src="/2020/03/02/jacoco使用/select_file.png" alt="选择报告生成位置"></p><p>选好后点击<code>save</code>按钮，会将列表中所有的测试用例运行的覆盖率结果导出。之后我们在之前指定的文件下找到生成的报告，用浏览器打开<code>index.html</code>文件，就可以看我们的覆盖率情况了，里面有很多不是我们的代码，我们只需找到我们包名下的文件查看即可。</p><p><img src="/2020/03/02/jacoco使用/as_coverage_html.png" alt="html报告"></p><blockquote><p>其中覆盖率为0%的是测试用例运行失败的情况</p></blockquote><p>到这里两种查看测试用例的方式都介绍完了，个人建议在测试整个项目的测试率是使时用jacoco，在查看某一个类的时候，使用<code>AS</code>自带工具。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本篇文章中的<code>jacoco</code>部分的内容是参考CSDN博主<code>唯鹿</code>单元测试分类的第八篇文章</p><p><a href="https://weilu.blog.csdn.net/article/details/79277483" target="_blank" rel="noopener">Android单元测试(八)：Dagger与单元测试</a></p><p>其中的项目截图也是其<a href="https://github.com/simplezhli/AndroidUT" target="_blank" rel="noopener">GitHub项目</a>的demo截取的。</p><p>强烈建议对单元测试感兴趣的小伙伴，通篇阅读<code>唯鹿</code>的单元测试系列文章，写的通俗易懂，深入浅出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章主要介绍在写完单元测试后，如何测试代码的覆盖率，从而更好的查缺补漏。下面我会介绍两种查看覆盖率的方法；一种是借助&lt;code&gt;Jaco
      
    
    </summary>
    
      <category term="Android" scheme="https://NicholasYG.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://NicholasYG.github.io/tags/Android/"/>
    
      <category term="java" scheme="https://NicholasYG.github.io/tags/java/"/>
    
      <category term="jacoco" scheme="https://NicholasYG.github.io/tags/jacoco/"/>
    
  </entry>
  
  <entry>
    <title>Mac上Chrome插件安装及打包方法</title>
    <link href="https://NicholasYG.github.io/2020/02/21/Chrome%E6%8F%92%E4%BB%B6/"/>
    <id>https://NicholasYG.github.io/2020/02/21/Chrome插件/</id>
    <published>2020-02-21T09:04:00.091Z</published>
    <updated>2020-02-24T03:39:17.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Chrome在我们日常工作中，是不可或缺的办公利器，加上Chrome的插件更是如虎添翼，可是应用商店中的插件需要科学上网才能获取。上有政策，下有对策，有一些网站专门提供chrome插件的下载，下面推荐两个：</p><p><a href="http://www.cnplugins.com/" target="_blank" rel="noopener">chrome插件网</a></p><p><a href="https://chrome.zzzmh.cn/" target="_blank" rel="noopener">极简插件</a></p><p>在上面这些网站中找到自己心仪的插件，下载下来。怎么安装就是我们要说的。<br><code>当然，如果你可以科学上网，还是建议直接在cherome商店里面安装，稳定又便捷</code></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>安装crx插件文件</li><li>安装zip插件文件</li><li>打包Chrome浏览器中的插件成crx</li></ul><h2 id="安装crx插件文件"><a href="#安装crx插件文件" class="headerlink" title="安装crx插件文件"></a>安装crx插件文件</h2><p>crx文件下载下来的后，很好安装，打开Chrome的扩展程序，直接拖拽进去就好；打开扩展程序的方式有两种</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>在浏览器中直接输入<code>chrome://extensions/</code>回车，就可以进入到扩展程序界面</p><p><img src="/2020/02/21/Chrome插件/entre_chrome.jpg" alt="打开扩展程序"></p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>按照下图1、2、3、的步骤，点击扩展程序进入到扩展程序界面</p><p><img src="/2020/02/21/Chrome插件/entre_chrome_2.png" alt="打开扩展程序"></p><p>进入到扩展界面后需要先把右上角的开发者模式打开，如下图所示：</p><p><img src="/2020/02/21/Chrome插件/open_developer.png" alt="打开扩展程序"></p><p>注意：这里说一下，如果开发者模式没有打开，把crx插件拖拽进来你会发现，chrome会展示一个下载界面，让你选择当前crx放置的位置；在这种情况下打开chrome的开发者模式，再次拖拽进来，还是会展示下载界面，这时我们需要把chrome完全退出来，重新打开，在开发者模式打开的情况下，把crx文件拖拽到扩展界面中。</p><p>开发者模式开启后，把下载好的crx文件拖拽到扩展程序界面，会看到如下界面</p><p><img src="/2020/02/21/Chrome插件/push_install.png" alt="打开扩展程序"></p><p>如果插件和你当前的浏览器匹配的话会弹出下面的确认弹框</p><p><img src="/2020/02/21/Chrome插件/install_select.png" alt="打开扩展程序"></p><p>我们选择添加扩展程序按钮，就可以看到下载的crx文件已经安装到了chrome上</p><p><img src="/2020/02/21/Chrome插件/install_success.png" alt="打开扩展程序"></p><p>安装成功后记得把插件右下角的开关打开（默认是开着的），这时插件就会显示在浏览器的右上角位置，然后就可以愉快的使用了。</p><h2 id="安装zip插件文件"><a href="#安装zip插件文件" class="headerlink" title="安装zip插件文件"></a>安装zip插件文件</h2><p>当然有的时候安装并没有这么顺利，比如当你把crx文件拖拽进来以后，你会看到下面的情况：</p><p><img src="/2020/02/21/Chrome插件/install_failed_0.png" alt="打开扩展程序"></p><p>造成这种情况原因可能是这样：</p><blockquote><p>原因是Chrome更新时，改变了头部信息打包方式！<br>导致的老版本Chrome打包的crx插件，无法直接安装在新版本Chrome中<br>举个例子,开发人员在2018年3月用chrome68把他写的插件打包成crx文件.<br>此时用户也用chrome68,一切正常安装使用.<br>等到chrome73发布的时候,头部打包方式就大改版了<br>用户再安装”chrome68打包的crx”就会出现<code>CRX_HEADER_INVALID</code>错误<br>这就说明这个插件不适合直接拖动安装</p></blockquote><p>如果出现这种情况怎么解决呢，也不麻烦，只需要将我们下载的插件的<code>xxx.crx</code>改成<code>xxx.zip</code>，之后再次拖拽到扩展程序界面就可以了。值得注意的是改为zip后缀的插件包，拖拽到扩展程序界面的时候，不再有弹框提示，直接就安装好了，另外在安装的插件上会看到多出一个图标,提示是<code>未封装的扩展程序</code></p><p><img src="/2020/02/21/Chrome插件/install_success_other.png" alt="打开扩展程序"></p><p>并不会影响到插件的使用，正常使用就好。</p><h2 id="打包Chrome浏览器中的插件成crx"><a href="#打包Chrome浏览器中的插件成crx" class="headerlink" title="打包Chrome浏览器中的插件成crx"></a>打包Chrome浏览器中的插件成crx</h2><p>有的时候我们浏览器中很多好用的插件，想分享给同事，或者想要同事电脑中的某一个插件，在上面提到的网站中又没有找到，我们就可以把已经安装好的插件打包成crx文件，然后给其他人安装，下面就介绍打包流程。</p><h4 id="找到已经安装插件的位置"><a href="#找到已经安装插件的位置" class="headerlink" title="找到已经安装插件的位置"></a>找到已经安装插件的位置</h4><p>chrome上的每一个插件都有自己的id，这个id会对应安装位置的文件夹，我们先找到它，还是先打开<code>扩展程序</code>界面，在描述下方显示者id：</p><p><img src="/2020/02/21/Chrome插件/check_plugin_id.png" alt="打开扩展程序"></p><p>我们先记住这个id，或者复制出来，一会儿会用到。在chrome中，所有的插件都放置在下面的这个路径下面：</p><p><code>~/Library/Application Support/Google/Chrome/Default/Extensions</code></p><p>我们先看看这个文件夹下面都是什么：</p><p><img src="/2020/02/21/Chrome插件/chrome_id_file.png" alt="打开扩展程序"></p><p>可以看到里面都是一些id，图中圈住的就是刚才我们在<code>扩展程序</code>中看到的，想要打包的插件id。我们想要的东西已经找到了。</p><p>说一下上面的路径，不建议看着文件名一层一层点进去查看，可能也找不到，因为系统的<code>资源库</code>文件夹默认是隐藏的，这里建议在<code>访达</code>中，按快捷键<code>command + shift + G</code>，复制上面的路径，点<code>前往</code>，可直接跳转到插件的文件夹下，找到自己想要打包的插件id对应的文件夹。</p><p><img src="/2020/02/21/Chrome插件/jump_plugin_file.png" alt="打开扩展程序"></p><h4 id="把插件打包成crx"><a href="#把插件打包成crx" class="headerlink" title="把插件打包成crx"></a>把插件打包成crx</h4><p>上面文件找到到了，我们该如何打包呢？还是回到<code>扩展程序</code>界面，打开<code>开发者模式</code>,会看到，下面有三个按钮：</p><p><img src="/2020/02/21/Chrome插件/deveioper_pack_button.png" alt="打开扩展程序"></p><p>我们点击<code>打包扩展程序</code>，在弹出提示框中，<code>私钥文件（选填）</code>对应的，我们可以不选。点击<code>扩展程序根目录</code>对应的<code>浏览</code>按钮，之后会弹出<code>访达</code>界面，我们用快捷键<code>command + shift + G</code>，复制插件的路径，直接到达插件的放置文件夹下,到了文件夹下，我们需要点击id所对应的文件，然后会看到一个插件当前版本的文件夹，我们选中这个版本文件夹，然后点击<code>选择</code>按钮</p><p><img src="/2020/02/21/Chrome插件/select_plugin_file.png" alt="打开扩展程序"></p><p>回到打包界面的弹框，点击<code>打包扩展程序</code></p><p><img src="/2020/02/21/Chrome插件/select_pack_begin.png" alt="打开扩展程序"></p><p>如果不出意外，会弹出下面这样的打包成功的弹框</p><p><img src="/2020/02/21/Chrome插件/pack_success_dialog.png" alt="打开扩展程序"></p><p>我们看上面信息，给出了已经打好包的crx文件对应的路径，还有相配套的私钥文件，可以看出文件生成的位置还是在插件对应id的文件夹下，我们再次打开<code>访达</code>，用快捷键的方式来到id文件夹，打开就可以看到，除了之前的版本文件夹，还有两个新的的文件，一个是我们需要的crx插件包，另一个是相匹配的私钥文件。</p><p><img src="/2020/02/21/Chrome插件/pack_success_file.png" alt="打开扩展程序"></p><p>至此我们已安装插件的打包就完成了。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>有了crx文件，安装的方法上面已经说了，这里就不再赘述了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Chrome在我们日常工作中，是不可或缺的办公利器，加上Chrome的插件更是如虎添翼，可是应用商店中的插件需要科学上网才能获取。上有政策，
      
    
    </summary>
    
      <category term="其他" scheme="https://NicholasYG.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="chrome" scheme="https://NicholasYG.github.io/tags/chrome/"/>
    
      <category term="插件" scheme="https://NicholasYG.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="crx" scheme="https://NicholasYG.github.io/tags/crx/"/>
    
  </entry>
  
  <entry>
    <title>Java注解的基本用法</title>
    <link href="https://NicholasYG.github.io/2018/11/09/Java/"/>
    <id>https://NicholasYG.github.io/2018/11/09/Java/</id>
    <published>2018-11-09T08:01:25.000Z</published>
    <updated>2018-11-10T05:57:55.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章讲述java中注解的概念和注解的基础用法，文章中举例用到的注解、元注解只是一部分，平时工作中用到过，有错误或新的见解，请指出。</p><h2 id="注解概念"><a href="#注解概念" class="headerlink" title="注解概念"></a>注解概念</h2><p>注解你可以理解为是某个类、某个方法的标签，有了这个标签(注解),就具备了某一个功能，举个例子，我们有一个类实现一个接口中的方法，在继承的方法上面都会有<code>@Override</code>的注解，就代表了这个方法是属于继承方法；或者在方法使用<code>@Deprecated</code>注解，就表示该方法已经过期，调用的时候方法上会有中划线的提示。以上例子只是标识注解，还有更多的带有成员或者自定义的注解，往下慢慢看来了解吧。</p><h2 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h2><ul><li>jdk中的注解</li></ul><blockquote><p>例：@Override、@Deprecated等</p></blockquote><ul><li>来自第三方的注解</li></ul><blockquote><p>例：Retrofit中的@GET、@POST，Spring中的@Autowired等</p></blockquote><ul><li>自定义注解</li></ul><blockquote><p>根据原则定义自己需求的注解</p></blockquote><p>上面说的三种注解的分类，jdk中的注解，需要我们去查看api文档，逐个了解，这里不多做赘述，第三方的注解，也是属于自定义注解，是一些优秀的框架中定义的注解，我们在平时的工作中会经常用到，举例的Retrofit是Android中应用非常广泛的网络框架；而spring则是java后台常用的。最后一个自定义注解，就是我们今天主要要了解和学习的，看看怎样去定义一个注解。</p><h3 id="自定义注解原则"><a href="#自定义注解原则" class="headerlink" title="自定义注解原则"></a>自定义注解原则</h3><ul><li><p>使用@interface关键字定义注解</p></li><li><p>成员以无参无异常的方式声明</p></li><li><p>可以用default为成员设置默认值</p></li><li><p>添加元注解(下面会做单独的介绍)</p></li><li><p>示例:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 元注解</span><br><span class="line"> */</span><br><span class="line">@Target(TYPE)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">//@interface关键字</span><br><span class="line">public @interface Description &#123;</span><br><span class="line"></span><br><span class="line">    String name();//无参数无异常的方法声明</span><br><span class="line">    String gender();</span><br><span class="line">    int age()default 18;//使用default字段设置默认值</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解中成员变量的规则要求"><a href="#注解中成员变量的规则要求" class="headerlink" title="注解中成员变量的规则要求"></a>注解中成员变量的规则要求</h3><ul><li><p>在注解中声明的成员变量是有类型限制的，合法的类型包括基本数据类型及String、Class、Annotation、Enumeration,一般我们常用到就是基本数据类型和String</p></li><li><p>如果注解中只有一个成员，则方法名必须要写成<code>value()</code>,在使用的时候就可以忽略掉方法名和赋值符号(就是=)</p></li></ul><p>示例：定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Target(TYPE)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">public @interface Description2 &#123;</span><br><span class="line">    //一个成员的定义 方法名为vaule</span><br><span class="line">    String value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在注解中可以没有成员，没有成员的注解称为标识注解，就类似于jdk中的<code>@Override、@Deprecated</code></li></ul><h3 id="元注解-注解的注解"><a href="#元注解-注解的注解" class="headerlink" title="元注解:注解的注解"></a>元注解:注解的注解</h3><p>我们看到在定义自定义注解的时候，上面定义了一些<code>@Target、@Inherited</code>等字段，它们有什么作用呢？看看下面的解释</p><h4 id="Target注解"><a href="#Target注解" class="headerlink" title="@Target注解"></a>@Target注解</h4><ul><li><p>Target注解可以规定在哪些地方使用</p></li><li><p>Target定义的成员类型是ElementType数组，Target中可以传入多个参数</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">public @interface Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数的类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//使用的jdk8中的ElementType 在8之前没有TYPE_PARAMETER和TYPE_USE两个参数值</span><br><span class="line"></span><br><span class="line">ANNOTATION_TYPE,//注释类声明</span><br><span class="line">CONSTRUCTOR,//构造方法声明</span><br><span class="line">FIELD,//字段声明</span><br><span class="line">LOCAL_VARIABLE,//局部变量声</span><br><span class="line">METHOD,//方法声明</span><br><span class="line">PACKAGE,//包声明</span><br><span class="line">PARAMETER,//参数声明</span><br><span class="line">TYPE,//类、接口声明</span><br><span class="line">TYPE_PARAMETER,//类型参数声明</span><br><span class="line">TYPE_USE;//没搞懂这个，官方API中给出的注释是Use of a type</span><br></pre></td></tr></table></figure><ul><li>示例：<code>@Target({METHOD,TYPE})</code>表示可以作用于方法、类、接口等</li></ul><h4 id="Retention注解"><a href="#Retention注解" class="headerlink" title="@Retention注解"></a>@Retention注解</h4><ul><li><p>Retention指的是该注解的生命周期</p></li><li><p>参数类型</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CLASS,//只在源码显示，编译时会丢失</span><br><span class="line">RUNTIME,//编译时会记录到class中，运行时忽略</span><br><span class="line">SOURCE;//运行时存在，可以通过反射获取</span><br></pre></td></tr></table></figure><h4 id="Inherited注解"><a href="#Inherited注解" class="headerlink" title="@Inherited注解"></a>@Inherited注解</h4><ul><li><p>Inherited表示允许子类继承</p></li><li><p>属于标识注解</p></li></ul><h4 id="Documented注解"><a href="#Documented注解" class="headerlink" title="@Documented注解"></a>@Documented注解</h4><ul><li><p>生成javadoc时会包含注解的信息</p></li><li><p>属于标识注解</p></li></ul><h3 id="自定义注解用法："><a href="#自定义注解用法：" class="headerlink" title="自定义注解用法："></a>自定义注解用法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//多个成员用法</span><br><span class="line"></span><br><span class="line">@Description(name = &quot;gdy&quot;,gender = &quot;man&quot;,age = 20)</span><br><span class="line">public String getName() &#123;</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br><span class="line">//只有一个成员定义</span><br><span class="line">@Description2(&quot;gdy&quot;)</span><br><span class="line">public String getAge() &#123;</span><br><span class="line">    return age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们就用一个简单的小demo来演示一下注解的具体使用</p><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><h4 id="定义只有一个成员的注解"><a href="#定义只有一个成员的注解" class="headerlink" title="定义只有一个成员的注解"></a>定义只有一个成员的注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">public @interface TestAnn &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//定义了一个接口</span><br><span class="line">public interface Person &#123;</span><br><span class="line">    String name();</span><br><span class="line">    String gender();</span><br><span class="line">    int age();</span><br><span class="line">&#125;</span><br><span class="line">//实现类中使用注解</span><br><span class="line">@TestAnn(&quot;我是一个person实现类&quot;)</span><br><span class="line">public class DuoDuo implements Person &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @TestAnn(&quot;我的名字叫多多&quot;)</span><br><span class="line">    public String name() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String gender() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int age() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在运行时解析注解"><a href="#在运行时解析注解" class="headerlink" title="在运行时解析注解"></a>在运行时解析注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class myClass &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //1、使用类加载器加载类</span><br><span class="line">            Class duo = Class.forName(&quot;com.rxjava.model.DuoDuo&quot;);</span><br><span class="line">            //2、找到类上面的注解 </span><br><span class="line">            boolean isExist = duo.isAnnotationPresent(TestAnn.class);</span><br><span class="line">            if (isExist) &#123;</span><br><span class="line">                //3、获取注解实例，并输出值</span><br><span class="line">                TestAnn t = (TestAnn) duo.getAnnotation(TestAnn.class);</span><br><span class="line">                System.out.println(t.value());</span><br><span class="line">            &#125;</span><br><span class="line">            //4、获取每个方法上的值</span><br><span class="line">            Method[] duoMethods = duo.getMethods();</span><br><span class="line">            for (Method duoM : duoMethods) &#123;</span><br><span class="line">                boolean isMExist = duoM.isAnnotationPresent(TestAnn.class);</span><br><span class="line">                if (isMExist) &#123;</span><br><span class="line">                    TestAnn tm = duoM.getAnnotation(TestAnn.class);</span><br><span class="line">                    System.out.println(tm.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="/2018/11/09/Java/print_out.jpg" alt="输出结果"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本篇文章是根据慕课网java注解完全解析，总结出来的笔记，想更细致的了解注解的使用，可移步到慕课网去观看视频，另外还有一篇大神讲解的深入简出、通俗易懂，也可一并观摩。</p><p><a href="https://www.imooc.com/learn/456" target="_blank" rel="noopener">慕课网篇</a></p><p><a href="https://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener">通俗易懂篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章讲述java中注解的概念和注解的基础用法，文章中举例用到的注解、元注解只是一部分，平时工作中用到过，有错误或新的见解，请指出。&lt;/p
      
    
    </summary>
    
      <category term="java" scheme="https://NicholasYG.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://NicholasYG.github.io/tags/java/"/>
    
      <category term="注解" scheme="https://NicholasYG.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Android微信支付</title>
    <link href="https://NicholasYG.github.io/2018/10/27/Android%E6%94%AF%E4%BB%98/"/>
    <id>https://NicholasYG.github.io/2018/10/27/Android支付/</id>
    <published>2018-10-27T02:29:56.000Z</published>
    <updated>2018-10-27T07:34:24.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集成步骤"><a href="#集成步骤" class="headerlink" title="集成步骤"></a>集成步骤</h2><h3 id="先贴上官方文档的集成步骤"><a href="#先贴上官方文档的集成步骤" class="headerlink" title="先贴上官方文档的集成步骤"></a>先贴上官方文档的集成步骤</h3><p><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419319167&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">资源链接</a><br>微信支付所需要的资源文件（包含支付demo和签名生成工具）</p><p><a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_5" target="_blank" rel="noopener">集成步骤链接</a><br>按照官方文档，一步一步集成下去，你会发现一个接一个-1等着你。</p><h3 id="导入依赖库（jar包）"><a href="#导入依赖库（jar包）" class="headerlink" title="导入依赖库（jar包）"></a>导入依赖库（jar包）</h3><ul><li>导入相关文件，在eclipse上是导入jar包，在AS环境中，可以再build.gradle文件中，添加如下依赖即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">//包含统计功能</span><br><span class="line">   compile &apos;com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+&apos;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">dependencies &#123;</span><br><span class="line">   compile &apos;com.tencent.mm.opensdk:wechat-sdk-android-without-mta:+&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当然也还可以用导入jar包的方式，下载demo文件，找到libammsdk.jar，导入到自己的项目libs文件夹中(解压压缩包，在libs文件夹中找到libammsdk.jar)</li></ul><p><img src="/2018/10/27/Android支付/source_link.jpg" alt="资源下载"></p><p>下载地址同上面的资源链接，之后同步工程，jar包导入工作就算完成了。</p><h3 id="添加WXPayEntryActivity文件（微信结果回调的类）"><a href="#添加WXPayEntryActivity文件（微信结果回调的类）" class="headerlink" title="添加WXPayEntryActivity文件（微信结果回调的类）"></a>添加WXPayEntryActivity文件（微信结果回调的类）</h3><p>WXPayEntryActivity是微信支付结果的回调类，调用微信支付SDK之后返回的结果，都会此类中获取到，根据集成要求，此类必须放在指定的位置。</p><p><img src="/2018/10/27/Android支付/file_catalog.jpg" alt="回调类的位置"></p><p>如上图WXPayEntryActivity必须放在这个路径下面（在Project目录结构下 <code>main</code>–<code>java</code>–<code>自己的包名</code>–<code>wxapi</code>–<code>WXPayEntryActivity</code>），如果集成过微信分享，放置的文件位置是一样的。<br>然后在清单文件(AndroidManifest)中加入WXPayEntryActivity的相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--微信支付--&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.wxapi.WXPayEntryActivity&quot;</span><br><span class="line">    android:exported=&quot;true&quot;</span><br><span class="line">    android:launchMode=&quot;singleTop&quot;</span><br><span class="line">    android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">        &lt;data android:scheme=&quot;you appid&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>看一下里面的内容</p><p><img src="/2018/10/27/Android支付/WXPayEntryActivity.jpg" alt="onCreat内容"></p><p>在onCreat方法中，有一个布局文件，你可以自定义，微信支付调起以后，你想展示怎样的界面，如何告知用户，都可以在WXPayEntryActivity中展示，当然，也可以注释掉，不使用任何布局，获取到支付结果后，做相应的处理就行。<br>下面是获取支付结果的方法：</p><p><img src="/2018/10/27/Android支付/pay_method.jpg" alt="支付结果返回码"></p><p>demo中给出的onResp方法，会将支付结果以弹窗的形式显示出来。当然你可以根据不同的状态码做不同的操作，<br>仅供参考（code 0、支付成功  -1、支付失败  -2、取消支付）</p><p><img src="/2018/10/27/Android支付/code_state.jpg" alt="状态处理"></p><p>你可以根据不同的状态做相应的处理，文档也对三种状态有对应的解释：</p><p><img src="/2018/10/27/Android支付/error_code.jpg" alt="文档code说明"></p><p>其中支付失败，返回-1的场景有很多，后面再详细说明。</p><h3 id="调用微信支付"><a href="#调用微信支付" class="headerlink" title="调用微信支付"></a>调用微信支付</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void toWeChatPay(OrderModel orderModel) &#123;</span><br><span class="line">     IWXAPI wxapi = WXAPIFactory.createWXAPI(this, Const.WECHAT_PAY_APP_ID);    </span><br><span class="line">    if (wxapi.isWXAppInstalled()) &#123;//判断是否安装微信</span><br><span class="line">    wxapi.registerApp(Const.WECHAT_PAY_APP_ID);//把app注册到微信</span><br><span class="line">        //给PayReq赋值</span><br><span class="line">        PayReq req = new PayReq();</span><br><span class="line">        req.appId = Const.WECHAT_PAY_APP_ID;</span><br><span class="line">        req.partnerId = orderModel.partnerId;</span><br><span class="line">        req.prepayId = orderModel.prepayId;</span><br><span class="line">        req.packageValue = orderModel.packageValue;</span><br><span class="line">        req.nonceStr = orderModel.nonceStr;</span><br><span class="line">        req.timeStamp = orderModel.timeStamp;</span><br><span class="line">        req.sign = orderModel.sign;</span><br><span class="line">        //发起请求 调用微信支付</span><br><span class="line">        wxapi.sendReq(req);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ToastUtil.showToast(activity, &quot;请您先安装微信！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时的七个参数，可以查看具体的<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_12" target="_blank" rel="noopener">文档说明</a></p><p><img src="/2018/10/27/Android支付/parameter.jpg" alt="参数"></p><p>这些个参数，可以跟后台沟通，返回给我们使用，当然其中的appid可以定义成静态的全局变量,在使用之前最好做一下非空判断。</p><h3 id="调用返回-1分析"><a href="#调用返回-1分析" class="headerlink" title="调用返回-1分析"></a>调用返回-1分析</h3><p>以上步骤如果你已经全部完成，那么恭喜你集成算是成功了，接下来将是调用迎来的errCode = -1，在文档上，对于-1的解释是这样的：</p><blockquote><p>可能的原因：签名错误、未注册APPID、项目设置APPID不正确、注册的APPID与设置的不匹配、其他异常等</p></blockquote><p>对以上提到的错误原因我们一一分析：</p><h4 id="首先说说签名错误"><a href="#首先说说签名错误" class="headerlink" title="首先说说签名错误"></a>首先说说签名错误</h4><p>签名如何获取？根据文档提供的下载链接，下载签名工具，输入包名，生成app唯一的签名，在文档上有详细的说明，但是要注意生成的签名，debug包和release包生成的签名是不一样的，所以在微信开放平台中填写的签名一定要区分，在测试阶段使用的是debug包生成的签名，上线使用的必须是release包生成的签名，一句话，应用包和签名一致，如果签名不一致，就会造成支付失败，errCode返回-1的情况。如果集成的有微信分享，可以用微信分享验证签名是否正确，如果同一签名下，微信分享可以分享成功，那么微信支付的签名一定是对的，返回-1就从其他方面找原因。</p><h4 id="APPID错误"><a href="#APPID错误" class="headerlink" title="APPID错误"></a>APPID错误</h4><p> APPID是微信开放平台给应用分配的，从上面复制就行，可以把APPID放在本地（一般不会变的），在AndroidManifast中、调用微信支付、WXPayEntryActivity等都会用到APPID。</p><h4 id="参数错误"><a href="#参数错误" class="headerlink" title="参数错误"></a>参数错误</h4><p>APPID和签名都正确的情况，再去调用微信支付。可能会出现这样的情况：如果微信未登录的情况下，会把微信调起来，在登录的情况下，返回值还是-1，这时候就要考虑参数的问题了，从demo里面拿过来的appid和一系列参数，放到自己的项目里面是不行的，参数要使用自己的appid对应生成的参数才可以，调用起微信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;集成步骤&quot;&gt;&lt;a href=&quot;#集成步骤&quot; class=&quot;headerlink&quot; title=&quot;集成步骤&quot;&gt;&lt;/a&gt;集成步骤&lt;/h2&gt;&lt;h3 id=&quot;先贴上官方文档的集成步骤&quot;&gt;&lt;a href=&quot;#先贴上官方文档的集成步骤&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Android" scheme="https://NicholasYG.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://NicholasYG.github.io/tags/Android/"/>
    
      <category term="支付" scheme="https://NicholasYG.github.io/tags/%E6%94%AF%E4%BB%98/"/>
    
      <category term="微信" scheme="https://NicholasYG.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用AS上传lib(module)包到Nexus私服（3.x）</title>
    <link href="https://NicholasYG.github.io/2018/10/16/Nexus%E7%A7%81%E6%9C%8D%E4%B8%8A%E4%BC%A0/"/>
    <id>https://NicholasYG.github.io/2018/10/16/Nexus私服上传/</id>
    <published>2018-10-16T11:41:02.000Z</published>
    <updated>2018-10-16T12:12:19.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="本篇文章要解决的问题如下"><a href="#本篇文章要解决的问题如下" class="headerlink" title="本篇文章要解决的问题如下"></a>本篇文章要解决的问题如下</h3><ul><li>搭建nexus私服</li><li>在nexus上创建仓库</li><li>配置grald文件，上传lib(module)包</li><li>在AS中使用</li></ul><p>本篇文章是基于Mac系统的基础上，搭建nexus；和windows系统搭建稍有差异。另本版本是基于nexus3.13.0版本，请知晓。</p><h2 id="nexus服务器搭建"><a href="#nexus服务器搭建" class="headerlink" title="nexus服务器搭建"></a>nexus服务器搭建</h2><h3 id="java环境"><a href="#java环境" class="headerlink" title="java环境"></a>java环境</h3><p>此版本的nexus是基于java，要求java JRE的版本不低于1.8.0，所以安装之前，先检测自己本地安装的JRE版本是否符合要求。</p><ul><li>检测当前java版本命令，在终端输入<br><code>java -version</code></li></ul><p><img src="/2018/10/16/Nexus私服上传/jave_version.jpg" alt="版本图片"><br>如上图，版本在1.8以上就可以下载nexus啦。</p><h3 id="下载nexus"><a href="#下载nexus" class="headerlink" title="下载nexus"></a>下载nexus</h3><p>可以在<a href="https://www.sonatype.com/download-oss-sonatype" target="_blank" rel="noopener">官方网站</a>下载最新版本的nexus，选择OS X版本</p><p><img src="/2018/10/16/Nexus私服上传/download_nexus.jpg" alt="下载截图"></p><p>下载完成后，打开解压包，会看到如下的目录</p><p><img src="/2018/10/16/Nexus私服上传/nexus_bin.jpg" alt="nexus文件目录"></p><p>接着在终端进入到bin目录下，输入命令 <code>nexus start</code> 看到 Starting nexus 字样就说明启动成功了</p><p><img src="/2018/10/16/Nexus私服上传/nexus_start.jpg" alt="开启nexus"></p><h2 id="在nexus上创建私有仓库"><a href="#在nexus上创建私有仓库" class="headerlink" title="在nexus上创建私有仓库"></a>在nexus上创建私有仓库</h2><h3 id="访问nexus和界面介绍"><a href="#访问nexus和界面介绍" class="headerlink" title="访问nexus和界面介绍"></a>访问nexus和界面介绍</h3><p>在本地浏览器输入<code>http://localhost:8081/</code> 跳转到nexus首页</p><p><img src="/2018/10/16/Nexus私服上传/nexus_index_page.jpg" alt="nexus首页"></p><p>在<code>Sign in</code>登录入口登录账号，nexus提供了一个公用账号 账号：admin 密码：admin123,登录上之后点击下图中第一步进入到设置界面，如下：</p><p><img src="/2018/10/16/Nexus私服上传/repository_page.jpg" alt="nexus首页"></p><p>点击第二步跳转到创建仓库界面。</p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>跳转到创建仓库界面，如下图</p><p><img src="/2018/10/16/Nexus私服上传/repository_list_default.jpg" alt="仓库列表界面"></p><p>可以看到nexus为我们创建了默认的仓库，在type列有<code>proxy、group、hosted</code>等类型，这三种类型都有什么作用呢？且看下面的解释：</p><ul><li>proxy（远程代理仓库）</li></ul><blockquote><p>这种类型的仓库，可以设置一个远程仓库的链接。当用户向 proxy 类型仓库请求下载一个依赖构件时，就会先在自己的库里查找，如果找不到的话，就会从设置的远程仓库下载到自己的库里，然后返回给用户，相当于起到一个中转的作用。例如 maven-central 用来存储从 Maven 中央仓库下载过的构件。</p></blockquote><ul><li>group （聚合仓库）</li></ul><blockquote><p>在 Maven 里没有这个概念，是 Nexus 特有的。目的是将多个仓库聚合，对用户暴露统一的地址，这样用户就不需要配置多个地址，只要统一配置 group 的地址就可以了。group 仓库的聚合成员可以在仓库设置中添加和移除。例如 maven-public 是一个 group 类型的仓库，通过引用这个地址，可以访问组内成员仓库的所有构件。</p></blockquote><ul><li>hosted（宿主仓库）</li></ul><blockquote><p>我们自己的构件，上传的就是这样的仓库。目前 maven-releases 和 maven-snapshots 是 hosted 类型的仓库。我们可以上传到这两个仓库，也可以自己创建 hosted 仓库。</p></blockquote><p>接着点击<code>Create Repositories</code>按钮，跳转到选择仓库界面，选择<code>maven2（hosted）</code>仓库</p><p><img src="/2018/10/16/Nexus私服上传/select_page.jpg" alt="选择仓库界面"></p><p>接下来是仓库的配置，可以根据自己的需求来修改</p><p><img src="/2018/10/16/Nexus私服上传/repository_detail.jpg" alt="配置详情页"></p><p>对于上面Maven2中Version policy的配置，官方是这样解释的:</p><ul><li>Release</li></ul><blockquote><p>可以将Maven存储库配置为适用于发布版本策略的发布组件。中央存储库使用发布版本策略</p></blockquote><ul><li>Snapshot</li></ul><blockquote><p>持续开发通常使用快照版本策略支持的快照版本执行。这些版本值必须以POM文件中的-SNAPSHOT结尾。这允许重复上传，其中实际使用的数字由日期/时间戳和枚举数组成，而且检索仍然可以使用-SNAPSHOT版本字符串。存储库管理器和客户机工具管理从快照版本到时间戳值的转换的元数据文件。</p></blockquote><ul><li>Mixed</li></ul><blockquote><p>混合版本策略允许您在一个存储库中支持这两种方法。</p></blockquote><p>附上<a href="https://help.sonatype.com/repomanager3/maven-repositories" target="_blank" rel="noopener">官方文档</a>，可以去看其他的配置解释。</p><p>点击保存，仓库就创建好了。回到首页，选择Browse，就可以看到我们刚才创建的仓库</p><p><img src="/2018/10/16/Nexus私服上传/new_repository.jpg" alt="新创建仓库"></p><p>点击列表中的<code>Copy</code>按钮，从弹框中获取到仓库地址，暂时保存待会儿会用到。</p><h2 id="创建lib（module）包，通过gradle上传"><a href="#创建lib（module）包，通过gradle上传" class="headerlink" title="创建lib（module）包，通过gradle上传"></a>创建lib（module）包，通过gradle上传</h2><h3 id="新建lib（module）包"><a href="#新建lib（module）包" class="headerlink" title="新建lib（module）包"></a>新建lib（module）包</h3><p>打开Android Studio在项目中创建lib包，选择Android Library；具体步骤如下：<br>在项目上右键，选择<code>new</code> –&gt; <code>Module</code> –&gt; <code>选择Android library</code></p><p><img src="/2018/10/16/Nexus私服上传/new_lib.jpg" alt="新建lib"></p><p>接着next下一步就可以了</p><p><img src="/2018/10/16/Nexus私服上传/select_android.jpg" alt="选择Android类型"></p><p>在lib（module）中写自己想要上传的内容，简单写一个类一个方法可以在后面调用就可以。</p><h3 id="配置gradle文件"><a href="#配置gradle文件" class="headerlink" title="配置gradle文件"></a>配置gradle文件</h3><p>内容补充完成后，需要在自己创建的lib（module）包的<code>build.gradle</code>文件中添加上传的代码，代码内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;maven&apos;</span><br><span class="line">task androidSourcesJar(type: Jar) &#123;</span><br><span class="line">    classifier = &apos;sources&apos;</span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">&#125;</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives androidSourcesJar</span><br><span class="line">&#125;</span><br><span class="line">afterEvaluate &#123; project -&gt;</span><br><span class="line">    uploadArchives &#123;</span><br><span class="line">        repositories &#123;</span><br><span class="line">            mavenDeployer &#123;</span><br><span class="line">                    //远程仓库的地址</span><br><span class="line">                repository(url: &quot;http://localhost:8081/repository/TestRepositoris/&quot;) &#123;</span><br><span class="line">                    //nexus登录的用户名和密码</span><br><span class="line">                    authentication(userName: &quot;admin&quot;, password: &quot;admin123&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                pom.project &#123;</span><br><span class="line">                    /**</span><br><span class="line">                     * 这三个字段是组成后续引用的关键，举例：</span><br><span class="line">                     * 之后在项目中会这样引用</span><br><span class="line">                     * com.xxx:testlibrary:1.0.0</span><br><span class="line">                     */</span><br><span class="line">                    groupId &apos;com.xxx&apos;</span><br><span class="line">                    artifactId &apos;testlibrary&apos;</span><br><span class="line">                    version &apos;1.0.0&apos;//版本号 </span><br><span class="line">                    packaging &apos;aar&apos;//打包的格式</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为方便配置也可以将上述代码新建一个gradle上传文件，在lib的build.gradle文件中来引用，具体操作：在lib(module)包上右键 –&gt; <code>New</code> –&gt; <code>File</code>；</p><p><img src="/2018/10/16/Nexus私服上传/new_gradle.jpg" alt="创建gradle文件"></p><p>之后创建.gradle为后缀名的文件</p><p><img src="/2018/10/16/Nexus私服上传/file_gradle.jpg" alt="gradle文件"></p><p>将上面配置代码复制进去,接着打开lib(module)包的<code>build.gradle</code>文件，引入新建的gradle文件，在上面添加<code>apply from: &#39;./upload.gradle&#39;</code> upload.gradle指的就是你创建的gradle文件，引入到build.gradle文件中使用</p><p><img src="/2018/10/16/Nexus私服上传/quote_file.jpg" alt="引入文件"></p><p>最后还需要在项目根目录的build.gradle文件中添加我们的仓库地址</p><p><img src="/2018/10/16/Nexus私服上传/project_gradle.jpg" alt="项目的gradle"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:3.0.1&apos;</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line">        //对maven插件进行修改可以兼容android</span><br><span class="line">        classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.5&apos;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven&#123;//仓库的地址</span><br><span class="line">            url &apos;http://localhost:8081/repository/TestRepositoris/&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步一下文件，AS会把我们的lib(module)生成要上传的文件。</p><h3 id="上传lib-module-包到nexus私服"><a href="#上传lib-module-包到nexus私服" class="headerlink" title="上传lib(module)包到nexus私服"></a>上传lib(module)包到nexus私服</h3><p>在AS编辑器的右侧工具栏，点击Gradle –&gt; 选择自己的项目 –&gt; 点击upload文件 –&gt; 双击uploadArchives</p><p><img src="/2018/10/16/Nexus私服上传/upload_lib.jpg" alt="上传lib包"></p><p>等待上传完成之后，就可以去私服上查看啦。点击自己创建的仓库查看：</p><p><img src="/2018/10/16/Nexus私服上传/upload_list_brower.jpg" alt="浏览器列表"></p><p>切换视图，网页版的展示</p><p><img src="/2018/10/16/Nexus私服上传/upload_list_html.jpg" alt="html浏览"></p><p>至此上传部分的工作已经完成；接下来就是在项目使用了。</p><h2 id="在AS中使用仓库中的lib"><a href="#在AS中使用仓库中的lib" class="headerlink" title="在AS中使用仓库中的lib"></a>在AS中使用仓库中的lib</h2><h3 id="在项目中引用"><a href="#在项目中引用" class="headerlink" title="在项目中引用"></a>在项目中引用</h3><ul><li>复制仓库的地址，放置在你想要引用项目的根目录的<code>build.gradle</code>中。注意：这里的项目是放置另外一个项目中，和lib包不是在同一个项目</li></ul><p><img src="/2018/10/16/Nexus私服上传/quote_project_gradle.jpg" alt="新项目中的引用"></p><ul><li>然后在app的<code>build.gradle</code>中加入<code>compile &#39;com.test:testlibrary:1.0.0&#39;</code></li></ul><p><img src="/2018/10/16/Nexus私服上传/quote_app_grade.jpg" alt="app的gradle中"></p><p>同步一下，就可以在代码中愉快的使用了，我是在lib包中放了一些关于缓存的代码，在项目中使用：</p><p><img src="/2018/10/16/Nexus私服上传/user_code.jpg" alt="代码中使用"></p><p>点击进去查看ACache文件，可以看到路径</p><p><img src="/2018/10/16/Nexus私服上传/lib_path.jpg" alt="路径"></p><p>到这里整个建库、上传、使用整个流程都完成了。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>第一次写公开式博客，历时2天，中间写写停停，还好最后算是勉强完成；之前自己有想记录的东西，都是以笔记的形式记录下来，很是粗糙，自己能看懂就行，不够细致，这篇写下来感觉真的很能加强知识点深度，强迫自己看了平时不愿看的英文文档，还写了迟迟不肯动手的demo，当写完的那一刻有一种酣畅淋漓的舒爽。第一次写还有许多不足的地方，会不断去完善，去修正编写的方式。坚持写下去，做一个深入简出的讲述者。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>写这篇博客参考了几位前辈的博客，在这里贴上链接，他们写的都很好，很值得借鉴和学习。</p><p><a href="https://blog.csdn.net/qq_32452623/article/details/79385595" target="_blank" rel="noopener">Android-Nexus 搭建自己的 Maven 仓库 &amp; Gradle 上传依赖包</a></p><p><a href="https://www.cnblogs.com/whoislcj/p/6490120.html" target="_blank" rel="noopener">Android业务组件化之Gradle和Sonatype Nexus搭建私有maven仓库</a></p><p><a href="https://www.jianshu.com/p/348cdc711c00" target="_blank" rel="noopener">Android依赖管理与私服搭建</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;本篇文章要解决的问题如下&quot;&gt;&lt;a href=&quot;#本篇文章要解决的问题如下&quot; class=&quot;headerlink&quot; title=&quot;本
      
    
    </summary>
    
      <category term="java" scheme="https://NicholasYG.github.io/categories/java/"/>
    
    
      <category term="Android" scheme="https://NicholasYG.github.io/tags/Android/"/>
    
      <category term="java" scheme="https://NicholasYG.github.io/tags/java/"/>
    
      <category term="nexus" scheme="https://NicholasYG.github.io/tags/nexus/"/>
    
  </entry>
  
</feed>
