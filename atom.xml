<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>葛布斯</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://NicholasYG.github.io/"/>
  <updated>2020-04-08T15:17:46.517Z</updated>
  <id>https://NicholasYG.github.io/</id>
  
  <author>
    <name>葛布斯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>http基础学习笔记</title>
    <link href="https://NicholasYG.github.io/2020/04/08/http%E5%9F%BA%E7%A1%80/"/>
    <id>https://NicholasYG.github.io/2020/04/08/http基础/</id>
    <published>2020-04-08T12:05:46.394Z</published>
    <updated>2020-04-08T15:17:46.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>前言</li><li>http概念</li><li>工作方式</li><li>URL</li><li>请求方法</li><li>状态码</li><li>Header</li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章主要是记录自己复习<code>http</code>相关的知识点，为后续学习<code>Retrofit</code>打基础，简单记录一些零碎的点，以免忘记。</p><h1 id="http概念"><a href="#http概念" class="headerlink" title="http概念"></a>http概念</h1><p><code>http</code>是一种超文本的传输协议，是为了传输<code>HTML</code>语言的内容。位于<code>TCP/IP</code>协议族的顶层。</p><h1 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h1><p><code>http</code>的工作方式一般是这样的：</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>执行流程</p><ul><li>在浏览器输入链接或者是点击某一个链接 </li><li>浏览会把链接上的信息拼接好发送服务器</li><li>服务器收到以后，进行处理，把处理好的数据返回给浏览器</li><li>服务器拿到响应的数据，进行页面的渲染</li><li>流程结束</li></ul><h2 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h2><p>执行流程</p><ul><li>在手机上进入某个界面或者点击某一个按钮 </li><li>手机软件上的相关代码会带着http报文的信息发送到服务器 </li><li>服务器进行处理，然后返回给手机 </li><li>手机在收到响应的数据后，进行页面的渲染或者其他操作</li></ul><h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>先说<code>URL</code>的格式：</p><h2 id="URL格式"><a href="#URL格式" class="headerlink" title="URL格式"></a>URL格式</h2><p><code>URL</code>有三部分组成：<br>我们拿<code>https://nicholasyg.github.io/categories/</code>这个链接来举例子：</p><p>其中<code>https</code>为协议类型;<code>nicholasyg.github.io</code>为服务器地址；<code>categories</code>为路径。</p><p><img src="/2020/04/08/http基础/chrome_link.png" alt="http"></p><p>通俗点说：</p><ul><li>协议类型：就是我们用<code>http</code>或者<code>https</code></li><li>服务器地址(:端口号)：用来发给目标服务器的</li><li>路径：这是给服务看，用来查找我们想要的内容</li></ul><h1 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h1><ul><li><p>GET 获取服务器端的资源，对服务端的内容不做修改，不发送Body</p></li><li><p>POST ⽤于增加或修改资源，发送给服务器的内容写在 Body ⾥⾯</p></li><li><p>PUT 用于修改服务器的资源，发送给服务器的内容写在 Body ⾥⾯</p></li><li><p>DELETE 用于删除服务器的某个资源 不发送Body</p></li></ul><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><ul><li>1开头 表示的是临时性消息，比如 <code>100表示继续发送</code></li><li>2开头 这个见得比较多，200 就是成功</li><li>3开头 表示重定向，比如 <code>304 表示内容未改变</code></li><li>4开头 表示的一般是指客户端错误，都是可以修改的 比如<code>404 地址找不到</code></li><li>5开头 表示的是服务器错误 常见的有 <code>500 服务器异常</code></li></ul><h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>header中的内容，一般是指的请求或响应数据的描述，比如Body有多长，传输的是什么类型等等这些信息，可以称为数据的元数据，下面具体介绍常用的：</p><h2 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h2><p>目标主机</p><blockquote><p>注意：这个host并不是用来找服务器的，而是用来定位子服务器。比如我现在有一个<code>https://www.gbs.com/android</code>的网址,我想要去访问它，把它拼接好放在浏览器中，在发出请求之前，浏览器会拿着中间的域名，通过DNS去域名库中查找这一个域名，找到它所对应的IP地址服务器，然后把<code>Host</code>当作信息的一部分发送给对应的IP地址服务器，可能这个IP地址对应的服务器有好多个子服务器，绑定了很多个域名，这时候服务器就可以通过这个<code>Host</code>找到对应的域名，在这个对应的域名上查找信息返回。</p></blockquote><h2 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h2><p>指定Body的类型，主要有4种：</p><h3 id="text-html"><a href="#text-html" class="headerlink" title="text/html"></a>text/html</h3><ul><li>请求 Web ⻚页⾯是返回响应的类型，Body 中返回 html ⽂本</li></ul><h3 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www-form-urlencoded"></a>x-www-form-urlencoded</h3><ul><li>Web ⻚页⾯纯⽂本表单的提交⽅式</li></ul><h3 id="multitype-form-data"><a href="#multitype-form-data" class="headerlink" title="multitype/form-data"></a>multitype/form-data</h3><ul><li>Web ⻚页⾯含有⼆进制⽂件时的提交⽅式</li></ul><h3 id="application-json-image-jpeg-application-zip-…"><a href="#application-json-image-jpeg-application-zip-…" class="headerlink" title="application/json , image/jpeg , application/zip …"></a>application/json , image/jpeg , application/zip …</h3><ul><li>单项内容（⽂本或⾮⽂本都可以），⽤于 Web Api 的响应或者 POST / PUT 的请求</li></ul><h2 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h2><p>指定Body的字节长度</p><h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><p>指定重定向的⽬标 URL</p><h2 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h2><p>用户代理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;http概念&lt;/li&gt;
&lt;li&gt;工作方式&lt;/li&gt;
&lt;li&gt;URL&lt;/li&gt;
&lt;li&gt;请求方法&lt;/li&gt;
      
    
    </summary>
    
      <category term="Http" scheme="https://NicholasYG.github.io/categories/Http/"/>
    
    
      <category term="chrome" scheme="https://NicholasYG.github.io/tags/chrome/"/>
    
      <category term="http" scheme="https://NicholasYG.github.io/tags/http/"/>
    
      <category term="web" scheme="https://NicholasYG.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>用Junit4怎么在Android中做测试?</title>
    <link href="https://NicholasYG.github.io/2020/03/17/Junit4/"/>
    <id>https://NicholasYG.github.io/2020/03/17/Junit4/</id>
    <published>2020-03-17T13:25:39.801Z</published>
    <updated>2020-04-02T15:14:04.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章是记录自己在项目开发中进行单元测试时，学习的<code>junit4</code>相关的一些知识，整理一下，以便以后查阅，如有不对的地方，还忘大家指正。</p><p>下文中提到的AS，是指<code>Android studio</code></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>对单元测试的理解</li><li>在android环境中创建单元测试类</li><li>注解</li><li>断言的使用</li><li>参考</li></ul><h1 id="对单元测试的理解"><a href="#对单元测试的理解" class="headerlink" title="对单元测试的理解"></a>对单元测试的理解</h1><p>在我看来单元测试，就是去验证每一小块代码的结果是否达到自己的预期。但是在验证前，要把条件准备妥当才能进行验证流程。我们举一个简单例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int getSummation(int a,int b)&#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一个很简单的求和的方法，调用这个方法，假如传入的参数分别是<code>1</code>和<code>2</code>，我们预期的结果一定是<code>3</code>，如果返回的是非<code>3</code>的数字，那说明这个方法是有问题的。上面这个方法的单元测试按上面思路就这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">  public void getSummation() &#123;</span><br><span class="line">      //准备调用方法的条件</span><br><span class="line">      Summation summation = new Summation();</span><br><span class="line">      //调用方法</span><br><span class="line">      int result = summation.getSummation(1, 2);</span><br><span class="line">      //验证返回的结果等于3</span><br><span class="line">      assertEquals(3, result);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>项目中的其他有返回的方法也是按这种思路来进行验证，有了上面这个思路，接下来看看在<code>android</code>中如何利用<code>junit4</code>来进行单元测试。</p><h1 id="在android环境中创建单元测试类"><a href="#在android环境中创建单元测试类" class="headerlink" title="在android环境中创建单元测试类"></a>在android环境中创建单元测试类</h1><p>在用<code>AS</code>创建的项目的时候，默认在<code>build.gradle</code>中已经引入了<code>junit4</code></p><p><img src="/2020/03/17/Junit4/.png" alt=""></p><p>所以不用再另外添加依赖，那应该怎么写呢？我们还用上面的例子来举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Math &#123;</span><br><span class="line"></span><br><span class="line">public int getSummation(int a,int b)&#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要测试<code>getSummation</code>方法，在<code>AS</code>中</p><p><code>getSummation</code>方法在<code>Math</code>类里面</p><ul><li>注解</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* @Test:将一个普通的方法修饰成为一个测试方法</span><br><span class="line">* @Test(expected=XX.class) XX可以是异常类，在运行此测试方法时，会忽略掉异常类的错误，正常运行</span><br><span class="line">* @Test(timeout=毫秒 ) 测试方法的超时时间，当被测试方法耗时超过timeout时长，会终止该方法的测试</span><br><span class="line">* @BeforeClass：它会在所有的方法运行前被执行，static修饰</span><br><span class="line">* @AfterClass:它会在所有的方法运行结束后被执行，static修饰</span><br><span class="line">* @Before：会在每一个测试方法被运行前执行一次</span><br><span class="line">* @After：会在每一个测试方法运行后被执行一次</span><br><span class="line">* @Ignore:所修饰的测试方法会被测试运行器忽略</span><br><span class="line">* @RunWith:可以更改测试运行器 org.junit.runner.Runner （会单独说）</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><ul><li>断言</li></ul><p>预测被测试方法的结果，可判断函数的正确性</p><p>assertArrayEquals(expecteds, actuals)    查看两个数组是否相等。<br>assertEquals(expected, actual)    查看两个对象是否相等。类似于字符串比较使用的equals()方法<br>assertNotEquals(first, second)    查看两个对象是否不相等。<br>assertNull(object)    查看对象是否为空。<br>assertNotNull(object)    查看对象是否不为空。<br>assertSame(expected, actual)    查看两个对象的引用是否相等。类似于使用“==”比较两个对象<br>assertNotSame(unexpected, actual)    查看两个对象的引用是否不相等。类似于使用“!=”比较两个对象<br>assertTrue(condition)    查看运行结果是否为true。<br>assertFalse(condition)    查看运行结果是否为false。<br>assertThat(actual, matcher)    查看实际值是否满足指定的条件<br>fail()    让测试失败</p><ul><li>测试套件(Runwith的使用)<br>使用测试套件可以同时运行多个单元测试类，有以下几个特点:<blockquote><p>   1、写一个作为测试套件的入口类，这个类里不包含其他的方法<br>  2、更改测试运行器Suite.class<br>   3、将要测试的类作为数组传入到Suite.SuiteClasses（{}）</p></blockquote></li></ul><p>代码示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author gdy</span><br><span class="line"> * @date 2020-02-04</span><br><span class="line"> */</span><br><span class="line">@RunWith(Suite.class)</span><br><span class="line">@Suite.SuiteClasses(&#123;ListTest.class,MathUtilTest.class,Test1.class,Test2.class&#125;)</span><br><span class="line">public class SuiteTest &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数化设置(Runwith的使用)</li></ul><p>设置参数可以使被测方法，一次运行测试多套参数，减少代码量，具体的步骤如下：</p><blockquote><p>  1.更改默认的测试运行器为RunWith(Parameterized.class)<br>    2.声明变量来存放预期值 和结果值<br>    3.声明一个返回值 为Collection的公共静态方法，并使用@Parameters进行修饰<br>    4.为测试类声明一个带有参数的公共构造函数，并在其中为之声明变量赋值</p></blockquote><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(Parameterized.class)</span><br><span class="line">public class ParameterTest &#123;</span><br><span class="line"></span><br><span class="line">    int expect = 0;</span><br><span class="line">    int a1 = 0;</span><br><span class="line">    int a2 = 0;</span><br><span class="line">    @Parameterized.Parameters</span><br><span class="line">    public static Collection&lt;Object[]&gt; methed()&#123;</span><br><span class="line">        return Arrays.asList(new Object[][]&#123;</span><br><span class="line">                &#123;5,3,2&#125;,</span><br><span class="line">                &#123;6,3,3&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   public ParameterTest(int expect,int a1,int a2)&#123;</span><br><span class="line">        this.expect = expect;</span><br><span class="line">        this.a1 = a1;</span><br><span class="line">        this.a2 = a2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd()&#123;</span><br><span class="line">        Assert.assertEquals(expect,new MathUtil().add(a1,a2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章是记录自己在项目开发中进行单元测试时，学习的&lt;code&gt;junit4&lt;/code&gt;相关的一些知识，整理一下，以便以后查阅，如有不对的
      
    
    </summary>
    
      <category term="单元测试" scheme="https://NicholasYG.github.io/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="android" scheme="https://NicholasYG.github.io/tags/android/"/>
    
      <category term="java" scheme="https://NicholasYG.github.io/tags/java/"/>
    
      <category term="单元测试" scheme="https://NicholasYG.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android开发遇到的问题整合（持续更新）</title>
    <link href="https://NicholasYG.github.io/2020/03/11/android%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://NicholasYG.github.io/2020/03/11/android相关问题/</id>
    <published>2020-03-11T12:17:57.797Z</published>
    <updated>2020-07-15T02:06:42.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一篇文章用来记录平时在开发中遇到的除<code>gradle</code>外的其他问题，一是加强记忆，二来也方便后续再次遇到同类问题方便查找。</p><h1 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h1><h2 id="问题描述-Error-while-Launching-activity"><a href="#问题描述-Error-while-Launching-activity" class="headerlink" title="问题描述(Error while Launching activity)"></a>问题描述(Error while Launching activity)</h2><p>在开发过程中连接着手机联调的时候，程序已经安装在手机上，这时候因为一些原因把APP卸载了，再次点击<code>Run</code>重新运行程序，安装app，出现了下面的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: Activity class &#123;com.hencoder.hencoderpracticedraw7/com.hencoder.hencoderpracticedraw7.MainActivity&#125; does not exist.</span><br><span class="line"></span><br><span class="line">Error while Launching activity</span><br></pre></td></tr></table></figure><p><img src="/2020/03/11/android相关问题/run_failed.png" alt="运行出错"></p><p>提示说启动界面时出错了，再往上一行说启动页（这里是MainActivity）不存在。出现这个问题的原因应该是，AS认为装载的app还存在，启动页却找不到了。但是实际上我们已经卸载了。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在AS底部的工具栏中找到<code>Terminal</code>，打开，输入以下命令</p><p><code>adb uninstall 你的包名</code></p><p>我这里的包名是<code>com.hencoder.hencoderpracticedraw7</code>，所以就这样写：</p><p><code>adb uninstall com.hencoder.hencoderpracticedraw7</code></p><p>然后回车，出现<code>Success</code>字样</p><p><img src="/2020/03/11/android相关问题/uninstall.png" alt="卸载成功"></p><p>用adb的方式把app完全卸载掉，再次运行APP就可以了。</p><h2 id="打开AS出现以下提示（non-Gradle…Android-Gradle）"><a href="#打开AS出现以下提示（non-Gradle…Android-Gradle）" class="headerlink" title="打开AS出现以下提示（non-Gradle…Android-Gradle）"></a>打开AS出现以下提示（non-Gradle…Android-Gradle）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Compilation is not supported for following modules: xxx. Unfortunately you </span><br><span class="line"></span><br><span class="line">can&apos;t have non-Gradle Java modules and Android-Gradle modules in one project.</span><br></pre></td></tr></table></figure><p>翻译过来就是，在一个项目中不能有非渐变Java模块和Android渐变模块。具体什么是非渐变和渐变，我也不清楚[捂脸]，后续查到再补充</p><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p>我遇到这个问题的原因是，在项目提交的时候，把一个<code>lib</code>的<code>iml</code>文件删除了，之后再运行自动生成了两个<code>iml</code>并且和之前的也不相同。比如我项目中的<code>lib</code>名称是<code>image</code>，一般对应生成的<code>iml</code>文件就是<code>image.iml</code>，但是我删除之后生成的却是两个，并同时报出了上面的错误。<br>然后搜了一下找到了解决办法：</p><ul><li>关闭当前项目</li><li>关闭 <code>Android Studio</code></li><li>找到项目位置，删除项目中的<code>.idea</code>文件</li><li>删除项目中所有的<code>.iml</code>文件（每个lib下iml都要删，包括app中的）</li><li>重新打开<code>Android Studio</code></li></ul><p><a href="https://stackoverflow.com/questions/30142056/error-unfortunately-you-cant-have-non-gradle-java-modules-and-android-gradle" target="_blank" rel="noopener">stack overflow解决办法</a></p><p>收工</p><h2 id="“Default-activity-not-found”"><a href="#“Default-activity-not-found”" class="headerlink" title="“Default activity not found”"></a>“Default activity not found”</h2><p>在我们运行项目的时候，有时候会遇到这个问题：</p><p><img src="/2020/03/11/android相关问题/titlebar_error.png" alt="titlebar error"></p><p><code>app</code>上有一个小红叉，点击<code>run app</code>，又会出现下面的错误</p><p><img src="/2020/03/11/android相关问题/run_error.png" alt="run_error"></p><h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>确认在<code>app文件夹下的AndroidManifest.xml</code>文件中已经添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">        android:name=&quot;com.your.package.name.YourActivity&quot;</span><br><span class="line">        android:label=&quot;@string/app_name&quot;&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line">            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>如果添加以后还是不行，那看方法二</p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>点击工具栏的同步按钮</p><p><img src="/2020/03/11/android相关问题/sync_gradle.png" alt="sync"></p><p>同步以后，还是不行的话，就接着往下看</p><h4 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h4><p>在<code>Android Studio</code>中选择</p><p><code>File -&gt; Invalidate Caches / Restart...</code></p><p>之后在弹出的提示框上选择<code>Invalidate and Restart</code>按钮</p><h4 id="方法四："><a href="#方法四：" class="headerlink" title="方法四："></a>方法四：</h4><p>最后选择在<code>Android Studio</code>中选择</p><p><code>Build -&gt; Clean Project</code></p><p>以上四种方法都执行了，这个问题应该就解决。</p><p><a href="https://medium.com/@ranjithexpertisers/default-activity-not-found-in-android-studio-f260a00edd4a" target="_blank" rel="noopener">Medium解决办法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这一篇文章用来记录平时在开发中遇到的除&lt;code&gt;gradle&lt;/code&gt;外的其他问题，一是加强记忆，二来也方便后续再次遇到同类问题方便查
      
    
    </summary>
    
      <category term="Android" scheme="https://NicholasYG.github.io/categories/Android/"/>
    
    
      <category term="android" scheme="https://NicholasYG.github.io/tags/android/"/>
    
      <category term="java" scheme="https://NicholasYG.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Gradle问题整合（持续更新）</title>
    <link href="https://NicholasYG.github.io/2020/03/09/Gradle%E9%97%AE%E9%A2%98/"/>
    <id>https://NicholasYG.github.io/2020/03/09/Gradle问题/</id>
    <published>2020-03-09T13:28:57.914Z</published>
    <updated>2020-07-15T00:48:28.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章用来记录在平时开发过程中遇到的一些关于gradle的问题，有常用的命令，有一些常见或不常见的问题，会持续更新，遇到了就会加入进来。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>常用命令</li><li>常见问题</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>以下的所有命令，都是在项目的<code>Terminal</code>中运行</p><ul><li><code>ls ~/.gradle/wrapper/dists/</code></li></ul><p><img src="/2020/03/09/Gradle问题/gradle_list.png" alt="gradle列表"></p><p>用来查看下载过的所有的gradle版本。在我们<code>gradle-wrapper.properties</code>文件中，可以看到当前项目引用的<code>gradle</code>版本；在项目根目录的<code>build.gradle</code>中，我们可以看到当前依赖的<code>gradle</code>插件版本，插件版本和<code>gradle</code>版本是要对应的。如下图所示：</p><p><img src="/2020/03/09/Gradle问题/compare.png" alt="对照图"></p><p>上面是<a href="https://developer.android.google.cn/studio/releases/gradle-plugin#updating-plugin" target="_blank" rel="noopener">Android官方文档</a>给出的对照表，举个例子：</p><p>现在我项目用的插件版本是<code>3.5.3</code></p><p><img src="/2020/03/09/Gradle问题/build.png" alt="bulid.gradle"></p><p>那么参照上面的对照表我对应的gradle版本是<code>5.4.1</code>，需要在<code>5.4.1-5.6.4</code>之间选择一个版本</p><p><img src="/2020/03/09/Gradle问题/properties.png" alt="gradle-wrapper.properties"></p><blockquote><p>注意：请勿在版本号中采用动态依赖项（例如 ‘com.android.tools.build:gradle:2.+’），否则可能会导致意外的版本更新和难以解析的版本差异。</p></blockquote><p>有了上面的命令，你就可以根据你当前项目的插件版本，在已经下载的gradle版本中选择了，当然如果列表中没有，还是需要单独下载。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="gradlew-command-not-found（Mac版）"><a href="#gradlew-command-not-found（Mac版）" class="headerlink" title="gradlew: command not found（Mac版）"></a>gradlew: command not found（Mac版）</h3><p>这个问题是发生在mac上，我在项目的<code>Terminal</code>中，执行<code>gradlew assembleDebug --info</code>想查看下编译打包时的日志信息，结果报出了：</p><p><code>zsh: command not found: gradlew</code></p><p>刚开始以为是自己的环境配置有问题，试了试自己的adb命令是好使的。最后在搜了一下，原来在<code>Linux</code>或<code>Unix</code>上执行需要加上<code>./</code>,命令就变成了这样：</p><p><code>./gradlew assembleDebug --info</code></p><p>具体的原因是这样的：</p><blockquote><p>你直接执行脚本的话，shell会在变量包含的路径里去找文件。但是，linux/unix为了安全的问题，并没有把当前路径放到PAHT中，并且也不推荐这样做.</p></blockquote><p>当然我看网上也有避免这个错误的方法，配置一下<code>path</code>就可以了，具体的配置方式，去网上搜一下就好了。<br>可能在你加上<code>./</code>之后，执行命令的时候，又有新的问题出现了：</p><p><code>zsh: ./gradlew: Permission denied</code></p><p>没权限！</p><p>这个我们需要在执行下一个命令</p><p><code>chmod +x gradlew</code></p><p>就在当前的目录执行就好，之后再次执行<code>gradlew assembleDebug --info</code>就可以了。</p><p>放一张图</p><p><img src="/2020/03/09/Gradle问题/process.png" alt="执行流程"></p><blockquote><p>说一点，但是我在一个项目中，执行了chmod +x gradlew命令以后，还是说没权限，然后我就把命令变成了chmod +x *，之后就好使了，不知道什么原因。只在一个项目中出现了这个问题，不建议直接使用这种方式，因为我不知道会不会有什么影响，但如果上面的命令你试了以后确实不好使，可以尝试一下这种方式。当然如果有知道原因的小伙伴可以告诉我一下。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章用来记录在平时开发过程中遇到的一些关于gradle的问题，有常用的命令，有一些常见或不常见的问题，会持续更新，遇到了就会加入进来。&lt;
      
    
    </summary>
    
      <category term="Android" scheme="https://NicholasYG.github.io/categories/Android/"/>
    
    
      <category term="gradle" scheme="https://NicholasYG.github.io/tags/gradle/"/>
    
      <category term="android" scheme="https://NicholasYG.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>生成Android单元测试代码覆盖率报告的两种方式</title>
    <link href="https://NicholasYG.github.io/2020/03/02/jacoco%E4%BD%BF%E7%94%A8/"/>
    <id>https://NicholasYG.github.io/2020/03/02/jacoco使用/</id>
    <published>2020-03-02T06:34:23.416Z</published>
    <updated>2020-03-02T13:01:54.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章主要介绍在写完单元测试后，如何测试代码的覆盖率，从而更好的查缺补漏。下面我会介绍两种查看覆盖率的方法；一种是借助<code>Jacoco</code>，通过<code>Gradle</code>生成html报告。另一种是使用Android Studio自带的<code>Coverage</code>，在运行后展示在<code>Coverage</code>列表中，再根据需求导出即可。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>配置信息</li><li>使用Jacoco查看代码覆盖率</li><li>使用AS自带Coverage查看代码覆盖率</li><li>参考</li></ul><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><p>在测试前先说一下，现在用的各种包的版本和AS版本</p><ul><li>Android Studio 3.5.2</li><li>SDK 28</li><li>Gradle 3.4.2</li><li>Java JRE 1.8.0</li><li>Jacoco 0.8.5</li></ul><p>因为版本的不同，在配置上或界面上的展示效果也不尽相同，接下来我们进入正题，开始代码覆盖率的查看。</p><h2 id="使用Jacoco查看代码覆盖率"><a href="#使用Jacoco查看代码覆盖率" class="headerlink" title="使用Jacoco查看代码覆盖率"></a>使用Jacoco查看代码覆盖率</h2><h3 id="添加Jacoco-gradle文件"><a href="#添加Jacoco-gradle文件" class="headerlink" title="添加Jacoco.gradle文件"></a>添加<code>Jacoco.gradle</code>文件</h3><p><code>Jacoco.gradle</code>文件默认不会自动生成需要自己手动添加，添加的位置和你要测试Moudle或者Lib包中的<code>build.gradle</code>文件在同一层级：</p><p><img src="/2020/03/02/jacoco使用/add_jacoco.png" alt="放置位置"></p><p>创建好文件后，在文件中添加内容，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;jacoco&apos;</span><br><span class="line"></span><br><span class="line">jacoco &#123;</span><br><span class="line">    toolVersion = &quot;0.8.5&quot; //指定jacoco的版本</span><br><span class="line">    reportsDir = file(&quot;$buildDir/JacocoReport&quot;) //指定jacoco生成报告的文件夹</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType(Test) &#123;</span><br><span class="line">    jacoco.includeNoLocationClasses = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            //打开覆盖率统计开关</span><br><span class="line">            testCoverageEnabled = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//依赖于testDebugUnitTest任务</span><br><span class="line">task jacocoTestReport(type: JacocoReport, dependsOn: &apos;testDebugUnitTest&apos;) &#123;</span><br><span class="line">    group = &quot;reporting&quot; //指定task的分组</span><br><span class="line">    reports &#123;</span><br><span class="line">        xml.enabled = true //开启xml报告</span><br><span class="line">        html.enabled = true //开启html报告</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    def debugTree = fileTree(dir: &quot;$&#123;buildDir&#125;/intermediates/javac/debug/compileDebugJavaWithJavac/classes/你的包名&quot;, //指定类文件夹 包名以 / 分割</span><br><span class="line">            includes: [&quot;**/*.*&quot;], //包含类的规则,这里我们生成所有类的测试报告</span><br><span class="line">            excludes: [&apos;**/R.class&apos;,</span><br><span class="line">                       &apos;**/R$*.class&apos;,</span><br><span class="line">                       &apos;**/BuildConfig.*&apos;,</span><br><span class="line">                       &apos;**/Manifest*.*&apos;]) //排除类的规则</span><br><span class="line">            </span><br><span class="line">    def mainSrc = &quot;$&#123;project.projectDir&#125;/src/main/java&quot; //指定源码目录</span><br><span class="line"></span><br><span class="line">    sourceDirectories = files([mainSrc])</span><br><span class="line">    classDirectories = files([debugTree])</span><br><span class="line">    executionData = files(&quot;$&#123;buildDir&#125;/jacoco/testDebugUnitTest.exec&quot;) //指定报告数据的路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>jacoco.gradle</code>文件中的内容都有注释说明，重点说一下<code>def debugTree</code>选项</p><p><img src="/2020/03/02/jacoco使用/def_debuTree.png" alt="def debugTree"></p><p>这里指定的类文件夹，在<code>../classes/你的包名</code>后面写的就是你的包名，比如你的包名叫：</p><p><code>com.app.unit.test</code></p><p>那么在指定类文件夹这一项就这样写：</p><p><img src="/2020/03/02/jacoco使用/def_debuTree_pakeage.png" alt="def debugTree"></p><p>在配置里面说过当前使用的<code>gradle</code>是<code>3.4.2</code>，在<code>gradle3.x</code>之后<code>class</code>文件的目录是上面的：</p><p><code>/intermediates/javac/debug/compileDebugJavaWithJavac/classes/</code></p><p>如果你的<code>gradle</code>版本在<code>3.x</code>之前<code>class</code>文件目录需要替换成为：</p><p><code>/intermediates/classes/debug</code></p><p>两者对比写法：</p><p><img src="/2020/03/02/jacoco使用/def_debuTree_3.x.png" alt="3.x前后对比"></p><p>再有就是下面<code>includes</code>和<code>excludes</code>标签，前者是代表要测试哪些类，后者代表忽略哪些类，两者都可以指定多个文件，目前我没有找到忽略某个文件夹的方法，如果谁知道，可以跟我说一下。</p><h3 id="使用Jacoco进行测试"><a href="#使用Jacoco进行测试" class="headerlink" title="使用Jacoco进行测试"></a>使用<code>Jacoco</code>进行测试</h3><p><code>jacoco.gradle</code>文件配置好以后，我们需要项目的<code>buidle.gradle</code>中引用，这里的<code>buidle.gradle</code>就是和<code>jacoco.gradle</code>同一层级的文件，引用方式如下：</p><p><code>apply from: &#39;jacoco.gradle&#39;</code></p><p>把上面代码加入到<code>buidle.gradle</code>文件中，放置在最外层（第一行或第二行）。</p><p><img src="/2020/03/02/jacoco使用/apply_jacoco.png" alt="引用jacoco"></p><p>接着同步一下项目，我们就可以开始运行查看了。</p><h4 id="运行jacoco"><a href="#运行jacoco" class="headerlink" title="运行jacoco"></a>运行jacoco</h4><p>点击<code>AS</code>右侧的<code>gradle</code>工具栏</p><p><img src="/2020/03/02/jacoco使用/gradle_tool_1.png" alt="右侧gradle工具栏"></p><p>如果你在你的<code>AS</code>右侧没有看到<code>gradle</code>的标签，可以从<code>AS</code>上方的菜单栏进入：</p><p><code>View -- Tool Windows -- Gradle</code></p><p><img src="/2020/03/02/jacoco使用/gradle_tool_2.png" alt="view方式进入"></p><p>打开<code>gradle</code>后，找到其中的两个命令<code>testDebugUintTest</code>和<code>jacocoTestReport</code></p><p><img src="/2020/03/02/jacoco使用/two_command.png" alt="两个命令"></p><p>首先<code>双击</code>运行<code>testDebugUintTest</code>命令，之后在<code>AS</code>底部<code>Run</code>标签中可以看到，项目中所有的用例在运行，有错误会在列表中展示，最后测试多少用例，成功多少，失败多少，都会显示出来，我们可以根据提示进行修改，直到没有错误：</p><p><img src="/2020/03/02/jacoco使用/run_failed.png" alt="Run错误"></p><p>上图是双击后测试的结果，我们可以看到哪些测试用例出现了错误，而且给出错误提示。</p><p><img src="/2020/03/02/jacoco使用/run_success.png" alt="Run正确"></p><p>上图是经过改正后，所有的测试用例都通过了（有一个忽略的方法），这时我们的用例就跑完了。</p><p>接着我们<code>双击</code>运行<code>jacocoTestReport</code>命令，同样会在<code>Run</code>中展示，等运行完成，我们的报告也就生成了。</p><h4 id="查看报告"><a href="#查看报告" class="headerlink" title="查看报告"></a>查看报告</h4><p>刚才我们双击的<code>testDebugUintTest</code>命令，会生成单元测试的报告，而双击的<code>jacocoTestReport</code>命令会生成测试覆盖率报告，文件放置的位置在你测试的<code>Moudle</code>或<code>Lib</code>下的<code>build</code>文件夹下，报告在<code>reports</code>和<code>JacocoReports</code>中：</p><p><img src="/2020/03/02/jacoco使用/reports_path.png" alt="报告路径"></p><p>用浏览器分别打开<code>index.xml</code>文件可以看到详细的报告。</p><p>测试报告：</p><p><img src="/2020/03/02/jacoco使用/test_reports.png" alt="测试报告"></p><p>覆盖率报告：</p><p><img src="/2020/03/02/jacoco使用/test_coverage_reports.png" alt="覆盖率报告"></p><p>点击每项可以查看具体的测试情况，绿色代表已经测试部分，红色代表未测试到的部分，黄色代表部分执行，就像if else中的部分代码被执行。</p><p><img src="/2020/03/02/jacoco使用/color_detial.png" alt="覆盖率报告"></p><p>至此关于<code>Jacoco</code>覆盖率的相关介绍就结束了。</p><h2 id="使用AS自带Coverage查看代码覆盖率"><a href="#使用AS自带Coverage查看代码覆盖率" class="headerlink" title="使用AS自带Coverage查看代码覆盖率"></a>使用AS自带Coverage查看代码覆盖率</h2><p>除了<code>jacoco</code>三方库可以测试代码覆盖率外，<code>AS</code>自身也带有一种测试代码覆盖率的工具，下面我们就来介绍一下。</p><p>我们在运行测试类的时候，有两种方式；一种是在测试类中点击类名所在行的左侧，选择<code>Run xx.class</code>：</p><p><img src="/2020/03/02/jacoco使用/run_test_1.png" alt="运行测试类1"></p><p>或者是点击选中此类，右键，然后<code>Run xx.class</code>：</p><p><img src="/2020/03/02/jacoco使用/run_test_2.png" alt="运行测试类2"></p><p>上图可以看到箭头所指的就是我们运行测试类时，选择的方式。我们再看图中被圈住的命令</p><p><code>Run xx.class With Coverage</code></p><p>这一个命令，就是我们要说的另一种生成覆盖率报告的方式。</p><p>我们选择一个类，运行<code>Run xx.class With Coverage</code>命令，然后会出现下面的弹框：</p><p><img src="/2020/03/02/jacoco使用/add_dialog.png" alt="添加弹框"></p><p>我们选择中间的按钮<code>Add to active suites</code>，就会看到我们测试的类，添加到了<code>Coverage</code>工具栏的列表中，如下图所示：</p><p><img src="/2020/03/02/jacoco使用/coverage_list.png" alt="覆盖率列表"></p><p>我们看一下这个列表，在列表第一行可以看到<code>Element</code>、<code>Class</code>、<code>Method</code>、<code>Line</code>等选项（红框圈住的位置），它们分别代表的是<code>测试的类所在路径/包</code>、<code>此路径下类测试占比</code>、<code>方法数测试占比</code>、<code>代码测试的覆盖率</code>我们都可以看到，其中的<code>Line</code>就是我们需要的代码覆盖率。</p><p>可能你在点击按钮<code>Add to active suites</code>时，在<code>Coverage</code>工具栏的工具栏中并没有出现列表中的内容，而是显示一句话：</p><p><code>no coverage results. click Edit to fix configuration settings</code></p><p>解决方法是：我们点击界面上的<code>Edit</code>按钮，此时会跳转到<code>Edit configurations</code>界面，我们选择Junit测试选项，选中测试的类，在右侧选择<code>code coverage</code>标签，把下方的<code>Enable coverage in test folders</code>勾选上，别忘了最后点击<code>apply</code>按钮，操作步骤如下：</p><p><img src="/2020/03/02/jacoco使用/coverage_disable.png" alt="coverage不显示的情况"></p><p>选中之后，再重复上述操作，就可以在列表中看到覆盖率等内容了。</p><p>上面只说了看了一个测试文件的方式，如果想要看二个或者多个测试类的覆盖率的怎么做呢，只需要继续运行其他想看的类，选择<code>Add to active suites</code>按钮，测试的文件就添加到列表中了。</p><p>如果想要测试整个项目的代码覆盖率情况，我们可以点击<code>test</code>目录下<code>java</code>文件下项目包名，点击右键，选择<code>Run xx With Coverage</code>，具体操作如下：</p><p><img src="/2020/03/02/jacoco使用/project_test.png" alt="整个项目测试"></p><p>等测试用例运行完之后，接下来的操作和前面介绍的测试一个类的方式一样，只是这时候展示在列表中的文件有点多：</p><p><img src="/2020/03/02/jacoco使用/all_list.png" alt="完整目录列表"></p><p>我们从文件中顺着包名的顺序找到我们的测试文件，可以点进去看代码的覆盖率实际上这时我们可以在左侧的<code>Project</code>目录中看到，每个文件夹下的代码的测试覆盖率情况。</p><p><img src="/2020/03/02/jacoco使用/prject_check_coverage.png" alt="project看覆盖率"></p><p>点进测类的代码，在左侧也可以看到被测试到每一行代码都会有绿色的线条标注。</p><p><img src="/2020/03/02/jacoco使用/code_tag.png" alt="代码标记"></p><blockquote><p>注意：如果所有的类一起测试生成覆盖率报告，如果其中的某一个类没有测试通过，那么测试结果显示出的覆盖率为0%，遇到这种情况，我们只需将错误的位置修改后，单独运行，添加到列表中即可。</p></blockquote><p><img src="/2020/03/02/jacoco使用/coverage_faile.png" alt="覆盖率为0"></p><p>如果觉得这种查看的方式不爽，我们还可以生成像<code>jacoco</code>那样的html文件，方式也很简单。还是打开我们右侧的<code>Coverage</code>工具栏，在左侧我们看到有一排小的按钮，我们选择最下方的按钮：</p><p><img src="/2020/03/02/jacoco使用/export_button.png" alt="生成报告按钮"></p><p>在弹出的提示框中选择报告生成后放置的位置：</p><p><img src="/2020/03/02/jacoco使用/select_file.png" alt="选择报告生成位置"></p><p>选好后点击<code>save</code>按钮，会将列表中所有的测试用例运行的覆盖率结果导出。之后我们在之前指定的文件下找到生成的报告，用浏览器打开<code>index.html</code>文件，就可以看我们的覆盖率情况了，里面有很多不是我们的代码，我们只需找到我们包名下的文件查看即可。</p><p><img src="/2020/03/02/jacoco使用/as_coverage_html.png" alt="html报告"></p><blockquote><p>其中覆盖率为0%的是测试用例运行失败的情况</p></blockquote><p>到这里两种查看测试用例的方式都介绍完了，个人建议在测试整个项目的测试率是使时用jacoco，在查看某一个类的时候，使用<code>AS</code>自带工具。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本篇文章中的<code>jacoco</code>部分的内容是参考CSDN博主<code>唯鹿</code>单元测试分类的第八篇文章</p><p><a href="https://weilu.blog.csdn.net/article/details/79277483" target="_blank" rel="noopener">Android单元测试(八)：Dagger与单元测试</a></p><p>其中的项目截图也是其<a href="https://github.com/simplezhli/AndroidUT" target="_blank" rel="noopener">GitHub项目</a>的demo截取的。</p><p>强烈建议对单元测试感兴趣的小伙伴，通篇阅读<code>唯鹿</code>的单元测试系列文章，写的通俗易懂，深入浅出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章主要介绍在写完单元测试后，如何测试代码的覆盖率，从而更好的查缺补漏。下面我会介绍两种查看覆盖率的方法；一种是借助&lt;code&gt;Jaco
      
    
    </summary>
    
      <category term="Android" scheme="https://NicholasYG.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://NicholasYG.github.io/tags/Android/"/>
    
      <category term="java" scheme="https://NicholasYG.github.io/tags/java/"/>
    
      <category term="jacoco" scheme="https://NicholasYG.github.io/tags/jacoco/"/>
    
  </entry>
  
  <entry>
    <title>Mac上Chrome插件安装及打包方法</title>
    <link href="https://NicholasYG.github.io/2020/02/21/Chrome%E6%8F%92%E4%BB%B6/"/>
    <id>https://NicholasYG.github.io/2020/02/21/Chrome插件/</id>
    <published>2020-02-21T09:04:00.091Z</published>
    <updated>2020-02-24T03:39:17.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Chrome在我们日常工作中，是不可或缺的办公利器，加上Chrome的插件更是如虎添翼，可是应用商店中的插件需要科学上网才能获取。上有政策，下有对策，有一些网站专门提供chrome插件的下载，下面推荐两个：</p><p><a href="http://www.cnplugins.com/" target="_blank" rel="noopener">chrome插件网</a></p><p><a href="https://chrome.zzzmh.cn/" target="_blank" rel="noopener">极简插件</a></p><p>在上面这些网站中找到自己心仪的插件，下载下来。怎么安装就是我们要说的。<br><code>当然，如果你可以科学上网，还是建议直接在cherome商店里面安装，稳定又便捷</code></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>安装crx插件文件</li><li>安装zip插件文件</li><li>打包Chrome浏览器中的插件成crx</li></ul><h2 id="安装crx插件文件"><a href="#安装crx插件文件" class="headerlink" title="安装crx插件文件"></a>安装crx插件文件</h2><p>crx文件下载下来的后，很好安装，打开Chrome的扩展程序，直接拖拽进去就好；打开扩展程序的方式有两种</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>在浏览器中直接输入<code>chrome://extensions/</code>回车，就可以进入到扩展程序界面</p><p><img src="/2020/02/21/Chrome插件/entre_chrome.jpg" alt="打开扩展程序"></p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>按照下图1、2、3、的步骤，点击扩展程序进入到扩展程序界面</p><p><img src="/2020/02/21/Chrome插件/entre_chrome_2.png" alt="打开扩展程序"></p><p>进入到扩展界面后需要先把右上角的开发者模式打开，如下图所示：</p><p><img src="/2020/02/21/Chrome插件/open_developer.png" alt="打开扩展程序"></p><p>注意：这里说一下，如果开发者模式没有打开，把crx插件拖拽进来你会发现，chrome会展示一个下载界面，让你选择当前crx放置的位置；在这种情况下打开chrome的开发者模式，再次拖拽进来，还是会展示下载界面，这时我们需要把chrome完全退出来，重新打开，在开发者模式打开的情况下，把crx文件拖拽到扩展界面中。</p><p>开发者模式开启后，把下载好的crx文件拖拽到扩展程序界面，会看到如下界面</p><p><img src="/2020/02/21/Chrome插件/push_install.png" alt="打开扩展程序"></p><p>如果插件和你当前的浏览器匹配的话会弹出下面的确认弹框</p><p><img src="/2020/02/21/Chrome插件/install_select.png" alt="打开扩展程序"></p><p>我们选择添加扩展程序按钮，就可以看到下载的crx文件已经安装到了chrome上</p><p><img src="/2020/02/21/Chrome插件/install_success.png" alt="打开扩展程序"></p><p>安装成功后记得把插件右下角的开关打开（默认是开着的），这时插件就会显示在浏览器的右上角位置，然后就可以愉快的使用了。</p><h2 id="安装zip插件文件"><a href="#安装zip插件文件" class="headerlink" title="安装zip插件文件"></a>安装zip插件文件</h2><p>当然有的时候安装并没有这么顺利，比如当你把crx文件拖拽进来以后，你会看到下面的情况：</p><p><img src="/2020/02/21/Chrome插件/install_failed_0.png" alt="打开扩展程序"></p><p>造成这种情况原因可能是这样：</p><blockquote><p>原因是Chrome更新时，改变了头部信息打包方式！<br>导致的老版本Chrome打包的crx插件，无法直接安装在新版本Chrome中<br>举个例子,开发人员在2018年3月用chrome68把他写的插件打包成crx文件.<br>此时用户也用chrome68,一切正常安装使用.<br>等到chrome73发布的时候,头部打包方式就大改版了<br>用户再安装”chrome68打包的crx”就会出现<code>CRX_HEADER_INVALID</code>错误<br>这就说明这个插件不适合直接拖动安装</p></blockquote><p>如果出现这种情况怎么解决呢，也不麻烦，只需要将我们下载的插件的<code>xxx.crx</code>改成<code>xxx.zip</code>，之后再次拖拽到扩展程序界面就可以了。值得注意的是改为zip后缀的插件包，拖拽到扩展程序界面的时候，不再有弹框提示，直接就安装好了，另外在安装的插件上会看到多出一个图标,提示是<code>未封装的扩展程序</code></p><p><img src="/2020/02/21/Chrome插件/install_success_other.png" alt="打开扩展程序"></p><p>并不会影响到插件的使用，正常使用就好。</p><h2 id="打包Chrome浏览器中的插件成crx"><a href="#打包Chrome浏览器中的插件成crx" class="headerlink" title="打包Chrome浏览器中的插件成crx"></a>打包Chrome浏览器中的插件成crx</h2><p>有的时候我们浏览器中很多好用的插件，想分享给同事，或者想要同事电脑中的某一个插件，在上面提到的网站中又没有找到，我们就可以把已经安装好的插件打包成crx文件，然后给其他人安装，下面就介绍打包流程。</p><h4 id="找到已经安装插件的位置"><a href="#找到已经安装插件的位置" class="headerlink" title="找到已经安装插件的位置"></a>找到已经安装插件的位置</h4><p>chrome上的每一个插件都有自己的id，这个id会对应安装位置的文件夹，我们先找到它，还是先打开<code>扩展程序</code>界面，在描述下方显示者id：</p><p><img src="/2020/02/21/Chrome插件/check_plugin_id.png" alt="打开扩展程序"></p><p>我们先记住这个id，或者复制出来，一会儿会用到。在chrome中，所有的插件都放置在下面的这个路径下面：</p><p><code>~/Library/Application Support/Google/Chrome/Default/Extensions</code></p><p>我们先看看这个文件夹下面都是什么：</p><p><img src="/2020/02/21/Chrome插件/chrome_id_file.png" alt="打开扩展程序"></p><p>可以看到里面都是一些id，图中圈住的就是刚才我们在<code>扩展程序</code>中看到的，想要打包的插件id。我们想要的东西已经找到了。</p><p>说一下上面的路径，不建议看着文件名一层一层点进去查看，可能也找不到，因为系统的<code>资源库</code>文件夹默认是隐藏的，这里建议在<code>访达</code>中，按快捷键<code>command + shift + G</code>，复制上面的路径，点<code>前往</code>，可直接跳转到插件的文件夹下，找到自己想要打包的插件id对应的文件夹。</p><p><img src="/2020/02/21/Chrome插件/jump_plugin_file.png" alt="打开扩展程序"></p><h4 id="把插件打包成crx"><a href="#把插件打包成crx" class="headerlink" title="把插件打包成crx"></a>把插件打包成crx</h4><p>上面文件找到到了，我们该如何打包呢？还是回到<code>扩展程序</code>界面，打开<code>开发者模式</code>,会看到，下面有三个按钮：</p><p><img src="/2020/02/21/Chrome插件/deveioper_pack_button.png" alt="打开扩展程序"></p><p>我们点击<code>打包扩展程序</code>，在弹出提示框中，<code>私钥文件（选填）</code>对应的，我们可以不选。点击<code>扩展程序根目录</code>对应的<code>浏览</code>按钮，之后会弹出<code>访达</code>界面，我们用快捷键<code>command + shift + G</code>，复制插件的路径，直接到达插件的放置文件夹下,到了文件夹下，我们需要点击id所对应的文件，然后会看到一个插件当前版本的文件夹，我们选中这个版本文件夹，然后点击<code>选择</code>按钮</p><p><img src="/2020/02/21/Chrome插件/select_plugin_file.png" alt="打开扩展程序"></p><p>回到打包界面的弹框，点击<code>打包扩展程序</code></p><p><img src="/2020/02/21/Chrome插件/select_pack_begin.png" alt="打开扩展程序"></p><p>如果不出意外，会弹出下面这样的打包成功的弹框</p><p><img src="/2020/02/21/Chrome插件/pack_success_dialog.png" alt="打开扩展程序"></p><p>我们看上面信息，给出了已经打好包的crx文件对应的路径，还有相配套的私钥文件，可以看出文件生成的位置还是在插件对应id的文件夹下，我们再次打开<code>访达</code>，用快捷键的方式来到id文件夹，打开就可以看到，除了之前的版本文件夹，还有两个新的的文件，一个是我们需要的crx插件包，另一个是相匹配的私钥文件。</p><p><img src="/2020/02/21/Chrome插件/pack_success_file.png" alt="打开扩展程序"></p><p>至此我们已安装插件的打包就完成了。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>有了crx文件，安装的方法上面已经说了，这里就不再赘述了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Chrome在我们日常工作中，是不可或缺的办公利器，加上Chrome的插件更是如虎添翼，可是应用商店中的插件需要科学上网才能获取。上有政策，
      
    
    </summary>
    
      <category term="其他" scheme="https://NicholasYG.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="chrome" scheme="https://NicholasYG.github.io/tags/chrome/"/>
    
      <category term="插件" scheme="https://NicholasYG.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="crx" scheme="https://NicholasYG.github.io/tags/crx/"/>
    
  </entry>
  
  <entry>
    <title>利用Jenkins进行Android自动化构建</title>
    <link href="https://NicholasYG.github.io/2020/01/09/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/"/>
    <id>https://NicholasYG.github.io/2020/01/09/Jenkins自动化打包/</id>
    <published>2020-01-09T07:21:40.223Z</published>
    <updated>2020-09-15T06:17:34.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="搭建流程如下"><a href="#搭建流程如下" class="headerlink" title="搭建流程如下"></a>搭建流程如下</h3><ul><li>Jenkins的下载和运行</li><li>Android环境配置</li><li>创建Android项目及项目build配置</li><li>构建项目</li><li>结束语</li></ul><p>环境都是在Mac上配置的，Window上的配置还没试，有时间再研究啦。</p><h2 id="Jenkins的下载和运行"><a href="#Jenkins的下载和运行" class="headerlink" title="Jenkins的下载和运行"></a>Jenkins的下载和运行</h2><h3 id="Jenkins下载"><a href="#Jenkins下载" class="headerlink" title="Jenkins下载"></a>Jenkins下载</h3><p>Jenkins它是基于Java的独立程序，所以呢，你电脑上如果配置了java环境，理论上都是可以运行,引用官网上的话：</p><blockquote><p>Jenkins 是一个基于 Java 的独立程序，可以立即运行，包含 Windows、Mac OS X 和其他类 Unix 操作系统。</p></blockquote><p>Jenkins的安装方式有好几种；各个系统对应的安装包、通过Docker镜像、<code>war</code>包等。对比了一下感觉<code>war</code>形式的好像便捷一些，果断用这种方式（主要还是懒）。先去下载Jenkins的<code>war</code>包。<br>在<a href="https://jenkins.io/zh/download/" target="_blank" rel="noopener">Jenkins官网</a>，有各种安装方式的包,因为我们要用war包的形式嘛，所以下载它，下图红框圈的就是：</p><p><img src="/2020/01/09/Jenkins自动化打包/jenkins_download_war.png" alt="下载截图"></p><p>不知道什么原因，这个<code>war</code>它也不大（60M左右），但是下载的奇慢，得下载数小时，差评!<br>但是老铁们也不用着急，我把下载下来的<code>war</code>包上传到gitHub上了，想要先行一步的来这下吧，童叟无欺。<a href="https://jenkins.io/zh/download/" target="_blank" rel="noopener">gitHub下载</a></p><p>但是要说明一下我放置的这个版本是2.213下面<code>每周更新版</code>的最新的<code>war</code>包，可能现在你看到的官网已经有了新的版本，所以介意的话，就在官网上下载最新的。如果是想练练手应该问题不大，下就完事。</p><h3 id="运行Jenkins"><a href="#运行Jenkins" class="headerlink" title="运行Jenkins"></a>运行Jenkins</h3><p>下载完以后，就可以愉快的运行了，下载下来的这个包你随便放置，执行的时候你能找到就行。接着我们打开终端，开始运行：</p><p>输入<code>java -jar jenkins.war</code></p><p>注意这行命令得是在<code>jenkins.war</code>当前的目录下运行,不然找不到。</p><p>在运行过程中，你可能会看到这样一段话：</p><p><img src="/2020/01/09/Jenkins自动化打包/jenkins_deaful_pwd.jpg" alt="jenkins初始密码"></p><p>这个密码你现在可以先粘贴出来后面要用，当然，如果你觉得不方便，也可以在用到的时候再去找，后面还会有提示，等他默默的运行起来之后，我们就可以开始浏览jenkins了。</p><p>打开浏览器，在地址栏输入<code>localhost:8080</code>就能开始我们的<code>jenkins</code>之旅了。如果一切正常的话，首先看到的会是下面这个界面 解锁jenkins：</p><p><img src="/2020/01/09/Jenkins自动化打包/jenkins_full_pwd.jpg" alt="解锁jenkins"></p><p>上面让输入管理员密码，就是上面说的那一串密码，粘出来贴上去，如果找不到，上面提供了查看路径（那一行红字）进去看再粘贴出来就行了。</p><p>点<code>continue</code>，等一会儿，就会出来下一个界面，让选择安装插件，我们是新手，就选第一个推荐安装，放个图片：</p><p><img src="/2020/01/09/Jenkins自动化打包/jenkins_pic1.jpg" alt="jenkins安装插件选择界面"></p><p>接着就是漫长的等待，会装不少插件，装插件的界面：</p><p><img src="/2020/01/09/Jenkins自动化打包/jenkins_pic2.jpg" alt="jenkins安装插件"></p><p>等它装完后，会跳转到一个填写账号密码的界面，这里填的账号就是以后我们登录的账号了，给出图片：</p><p><img src="/2020/01/09/Jenkins自动化打包/jenkins_pic2.jpg" alt="jenkins填写用户信息"></p><p>按照提示的信息，每一项都填写好，保存就好了，成功后会有页面提示。至此jenkins的安装工作告一段落，接下来就可以配置一些环境和创建项目了。</p><h2 id="配置Android编译环境"><a href="#配置Android编译环境" class="headerlink" title="配置Android编译环境"></a>配置Android编译环境</h2><p>进入到jenkins界面后，我们先不急着创建项目，先去配置环境，在界面的左侧导航栏，找到<code>Manager Jenkins</code>接着在列表第四项找到<code>Global Tool Configuration</code>，点进去可以配置<code>Java JDK</code>和<code>Gradle</code>的环境,如下图:</p><p><img src="/2020/01/09/Jenkins自动化打包/jenkins_android_configure.png" alt="jenkins填写用户信息"></p><h3 id="配置java-JDK："><a href="#配置java-JDK：" class="headerlink" title="配置java JDK："></a>配置java JDK：</h3><p><img src="/2020/01/09/Jenkins自动化打包/jenkins_java_jdk.png" alt="jenkins填写用户信息"></p><ul><li>1、名称：随意写，没有特殊规定</li><li>2、路径：本地java JDK的路径</li></ul><p>这里说一下这个JDK路径，macOS本身带有java的环境，可以直接使用，可能不是最新的包，你可以选择升级，我们这里要填写的就是这个路径。如果你本地配置过java的环境变量（配置环境变量这里就不说了，网上很多，搜一哈），打开<code>.bash_profile</code>文件，找到JAVA_HOME对应的路径，复制出来放在这里就好。</p><p><code>打开命令 open ~/.bash_profile</code></p><p>你的配置信息可能是这样的，圈住的就是我们需要的路径：</p><p><img src="/2020/01/09/Jenkins自动化打包/jenkins_bash_profile.png" alt="bash_profile"></p><p>如果本地的JDK 不知道在哪个位置，就使用下面的方式查看：</p><p>终端输入<code>/usr/libexec/java_home -V</code>,你会看到下面的信息：</p><p><img src="/2020/01/09/Jenkins自动化打包/jenkins_java_home.png" alt="java_home"></p><p>从箭头指向的位置开始到结束，这个就是我们要配置的路径，如果你安装了多个JDK，会显示多个的信息，使用任何一个都可以，看你选择。</p><h3 id="配置Gradle："><a href="#配置Gradle：" class="headerlink" title="配置Gradle："></a>配置Gradle：</h3><p><img src="/2020/01/09/Jenkins自动化打包/jenkins_gradle.png" alt="jenkins填写用户信息"></p><ul><li>1、名称：随意写，没有特殊规定</li><li>2、路径：gradle的路径</li></ul><h4 id="查找gradle路径"><a href="#查找gradle路径" class="headerlink" title="查找gradle路径"></a>查找gradle路径</h4><ul><li>方法一</li></ul><p><code>gradle</code>的位置在Android studio3.5之前，可以按照</p><p><code>应用程序 --&gt; android studio --&gt; 右键 --&gt; 显示包内容 --&gt; Contents --&gt; gradle</code></p><p>找到<code>gradle</code>对应的位置，然后选择想要使用的gradle的版本，路径粘贴可以按以下操作：</p><p><code>选中文件--&gt;右键--&gt;显示简介--&gt;位置</code></p><p>将位置处所对应的路径粘贴出来；或者你可以把选择的<code>gradle</code>版本文件夹拖拽到终端里面，然后复制出全路径，放到我们图中<code>2</code>的位置。</p><ul><li>方法二</li></ul><p>另外一种方式是，打开本地的<code>.gradle</code>，从里面获取想要构建使用的gradle版本。由于<code>.gradle</code>文件默认是隐藏的，所以我们操作前需要先显示出隐藏文件。操作方式如下:</p><p>显示隐藏文件快捷键：<code>command⌘ + shift⇧ + .</code>(此操作在<code>用户</code>的的根目录下进行)</p><p>找到<code>.gradle</code>文件后，按如下操作： </p><p><code>.gradle --&gt; wrapper --&gt; dists --&gt; 你的gradle列表</code></p><p>按照上面的操作一层一层的进入到你的<code>gradle</code>列表里面，选择你中意的版本，按照方法一种的两种方法，复制出路径，放在图中<code>2</code>的位置。</p><p>到这里我们的<code>gradle</code>路径也配置好了，点击<code>sava</code>保存就行了。</p><h3 id="配置Android-SDK"><a href="#配置Android-SDK" class="headerlink" title="配置Android SDK"></a>配置Android SDK</h3><p>配置Android SDK和上面两个配置不在同一个界面。回退到<code>jenkins</code>的设置界面，点击<code>Configure System</code>，进入设置界面，找到<code>Global properties</code>属性，勾选<code>Environment variables</code>，填写上名称和对应的<code>Android SDK</code>的路径：</p><p><img src="/2020/01/09/Jenkins自动化打包/jenkins_android_sdk.png" alt=""></p><ul><li>1、勾选<code>Environment variables</code>属性</li><li>2、填写名字</li><li>3、填写SDK的路径</li></ul><p>SDK的路径也很好找，我们打开<code>Android studio</code>编辑器，在顶部的工具栏，找到<code>SDK Manager</code>按钮</p><p><img src="/2020/01/09/Jenkins自动化打包/jenkins_android_sdk_manager.png" alt=""></p><p>点击，就会显示Android所有的SDK版本，里面有些我们下载了，有的没下载，但是我们关注的不是这个，关注的是红框圈住的这个路径，复制出来，放在<code>2</code>的位置，如下：</p><p><img src="/2020/01/09/Jenkins自动化打包/jenkins_android_sdk_path.png" alt=""></p><p>到这里我们Android的运行环境差不多就配置好了，接下来就可以创建项目了。</p><h2 id="创建Android项目及项目build配置"><a href="#创建Android项目及项目build配置" class="headerlink" title="创建Android项目及项目build配置"></a>创建Android项目及项目build配置</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>准备工作都做完了，接下来开始创建项目，回到主页面。按图所示：</p><p><img src="/2020/01/09/Jenkins自动化打包/creat_android_project.png" alt=""></p><p>在项目上只需要写上名称即可，选择Freestyle project，保存。项目就创建完成了。接着进入到我们创建好的项目中，进行各项的配置</p><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><h4 id="General（常规配置）"><a href="#General（常规配置）" class="headerlink" title="General（常规配置）"></a>General（常规配置）</h4><p>进入到项目看到的第一项是general选项，看图：</p><p><img src="/2020/01/09/Jenkins自动化打包/general_with_project.png" alt=""></p><p>我们目前先把项目配置好，能跑起来；后面章节再说参数化构建相关的东西。这里只填写一下描述信息。</p><h4 id="SCM（Source-Code-Management）"><a href="#SCM（Source-Code-Management）" class="headerlink" title="SCM（Source Code Management）"></a>SCM（Source Code Management）</h4><p>接着是SCM模块，先上图：</p><p><img src="/2020/01/09/Jenkins自动化打包/scm_with_project.png" alt=""></p><p>这里主要设置构建项目的仓库地址，可以选择svn和git两种，我们这里以svn为例；分别填写svn的项目地址 ，和选择svn账号；默认svn账号的位置是空，需要点击Add按钮添加：</p><p><img src="/2020/01/09/Jenkins自动化打包/add_account_with_scm.png" alt=""></p><p>分别添加上你的账号和密码。保存之后就可以在前面界面上选中了。<code>地址</code>、<code>svn账号</code>都填写完，其他的选项保持默认就好，不需要另外操作。</p><p>再接着往下的两个标签<code>Build Triggers</code>,<code>Build Environment</code>暂时不做其他填写，保持默认就好。</p><h4 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h4><p>这一步是指定Gradle版本用来构建项目的，先点击<code>Add build step</code>按钮添加：</p><p><img src="/2020/01/09/Jenkins自动化打包/build_with_project.png" alt=""></p><p>选择<code>Invoke Gradle script</code>选项，接着会看到下面要填写的选项</p><p><img src="/2020/01/09/Jenkins自动化打包/select_version_with_build.png" alt=""></p><p><code>Gradle Version</code>选项就是我们刚才在上面配置的gradle，选择你刚才命名的gradle名称，接着在<br><code>Tasks</code>选项中，写上我们想要执行的gradle命令；这里需要注意一下，不要勾选<code>Use Gradle Wrapper</code>虽然<code>Tasks</code>是在它下方，但不属于它里面的一个选项：</p><p><img src="/2020/01/09/Jenkins自动化打包/add_tasks_with_build.png" alt=""></p><p><code>Tasks</code>中的命令就相当于我们在项目的终端输入的命令一样；</p><p>比如想要构建项目的<code>debug</code>版本：</p><p><code>assembleDebug</code></p><p>正式版：</p><p><code>assembleRelease</code></p><p>当然如果你在项目中配置了<code>Flavors</code>多渠道打包，在这里也是一样可以在<code>Tasks</code>中编辑。比如我配置了小米和华为渠道，在<code>Flavors</code>中的命名分别是<code>xiaomi</code>和<code>huawei</code>，那么在<code>Tasks</code>中命名就是：</p><p><code>assembleXiaomiRelease</code>和<code>assembleHuaweiRelease</code>。</p><p>关于<code>Flavors</code>配置多渠道相关问题这里不多赘述，有兴趣可以参考下面这篇文章：</p><p><a href="https://www.yuque.com/docs/share/f79dbc57-887a-47e9-9f4e-cadb0d4e6627?#" target="_blank" rel="noopener">Gradle productFlavors多版本打包</a></p><p>到这里我们的项目配置就完成了，点击保存按钮，接着就是最后一步构建了。</p><h2 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h2><p>保存完成后，跳转到项目的菜单页面，点击立即构建按钮，项目就开始运行啦：</p><p><img src="/2020/01/09/Jenkins自动化打包/project_with_build_start.png" alt=""></p><p>在构建的过程中，如果想看控制台日志，可以选择正在构建的项目，每次构建的版本都在这里罗列。</p><p><img src="/2020/01/09/Jenkins自动化打包/project_with_build_list.png" alt=""></p><p>点击后面的小三角有下拉列表，选择<code>Console Output</code>点进去，就是项目的构建日志了。</p><p><img src="/2020/01/09/Jenkins自动化打包/project_with_build_log.png" alt=""></p><p>等待项目构建完成，如果看到下面熟悉的信息，那么我们的项目就构建成功了。</p><p><img src="/2020/01/09/Jenkins自动化打包/project_with_build_success.png" alt=""></p><p>如果项目项目未构建成功，log中也会给出对应的提示，需要我们按需解决。</p><h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><p>构建成功，打的包在<code>Work space</code>列表中。</p><p><img src="/2020/01/09/Jenkins自动化打包/project_with_workspace.png" alt=""></p><p>点开后可以看到，和我们的Android studio中的目录结构是一样的，构建成功的文件也在build文件中，这里不再展开叙述。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>以上就是Jenkins下载安装、环境配置和创建Android项目的过程，介绍了基本的构建方式，后续有时间会介绍如何进行参数化构建，让jenkins有更多的玩法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;搭建流程如下&quot;&gt;&lt;a href=&quot;#搭建流程如下&quot; class=&quot;headerlink&quot; title=&quot;搭建流程如下&quot;&gt;&lt;/a&gt;搭
      
    
    </summary>
    
      <category term="Android" scheme="https://NicholasYG.github.io/categories/Android/"/>
    
    
      <category term="gradle" scheme="https://NicholasYG.github.io/tags/gradle/"/>
    
      <category term="android" scheme="https://NicholasYG.github.io/tags/android/"/>
    
      <category term="jenkins" scheme="https://NicholasYG.github.io/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Java注解的基本用法</title>
    <link href="https://NicholasYG.github.io/2018/11/09/Java/"/>
    <id>https://NicholasYG.github.io/2018/11/09/Java/</id>
    <published>2018-11-09T08:01:25.000Z</published>
    <updated>2018-11-10T05:57:55.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章讲述java中注解的概念和注解的基础用法，文章中举例用到的注解、元注解只是一部分，平时工作中用到过，有错误或新的见解，请指出。</p><h2 id="注解概念"><a href="#注解概念" class="headerlink" title="注解概念"></a>注解概念</h2><p>注解你可以理解为是某个类、某个方法的标签，有了这个标签(注解),就具备了某一个功能，举个例子，我们有一个类实现一个接口中的方法，在继承的方法上面都会有<code>@Override</code>的注解，就代表了这个方法是属于继承方法；或者在方法使用<code>@Deprecated</code>注解，就表示该方法已经过期，调用的时候方法上会有中划线的提示。以上例子只是标识注解，还有更多的带有成员或者自定义的注解，往下慢慢看来了解吧。</p><h2 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h2><ul><li>jdk中的注解</li></ul><blockquote><p>例：@Override、@Deprecated等</p></blockquote><ul><li>来自第三方的注解</li></ul><blockquote><p>例：Retrofit中的@GET、@POST，Spring中的@Autowired等</p></blockquote><ul><li>自定义注解</li></ul><blockquote><p>根据原则定义自己需求的注解</p></blockquote><p>上面说的三种注解的分类，jdk中的注解，需要我们去查看api文档，逐个了解，这里不多做赘述，第三方的注解，也是属于自定义注解，是一些优秀的框架中定义的注解，我们在平时的工作中会经常用到，举例的Retrofit是Android中应用非常广泛的网络框架；而spring则是java后台常用的。最后一个自定义注解，就是我们今天主要要了解和学习的，看看怎样去定义一个注解。</p><h3 id="自定义注解原则"><a href="#自定义注解原则" class="headerlink" title="自定义注解原则"></a>自定义注解原则</h3><ul><li><p>使用@interface关键字定义注解</p></li><li><p>成员以无参无异常的方式声明</p></li><li><p>可以用default为成员设置默认值</p></li><li><p>添加元注解(下面会做单独的介绍)</p></li><li><p>示例:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 元注解</span><br><span class="line"> */</span><br><span class="line">@Target(TYPE)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">//@interface关键字</span><br><span class="line">public @interface Description &#123;</span><br><span class="line"></span><br><span class="line">    String name();//无参数无异常的方法声明</span><br><span class="line">    String gender();</span><br><span class="line">    int age()default 18;//使用default字段设置默认值</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解中成员变量的规则要求"><a href="#注解中成员变量的规则要求" class="headerlink" title="注解中成员变量的规则要求"></a>注解中成员变量的规则要求</h3><ul><li><p>在注解中声明的成员变量是有类型限制的，合法的类型包括基本数据类型及String、Class、Annotation、Enumeration,一般我们常用到就是基本数据类型和String</p></li><li><p>如果注解中只有一个成员，则方法名必须要写成<code>value()</code>,在使用的时候就可以忽略掉方法名和赋值符号(就是=)</p></li></ul><p>示例：定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Target(TYPE)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">public @interface Description2 &#123;</span><br><span class="line">    //一个成员的定义 方法名为vaule</span><br><span class="line">    String value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在注解中可以没有成员，没有成员的注解称为标识注解，就类似于jdk中的<code>@Override、@Deprecated</code></li></ul><h3 id="元注解-注解的注解"><a href="#元注解-注解的注解" class="headerlink" title="元注解:注解的注解"></a>元注解:注解的注解</h3><p>我们看到在定义自定义注解的时候，上面定义了一些<code>@Target、@Inherited</code>等字段，它们有什么作用呢？看看下面的解释</p><h4 id="Target注解"><a href="#Target注解" class="headerlink" title="@Target注解"></a>@Target注解</h4><ul><li><p>Target注解可以规定在哪些地方使用</p></li><li><p>Target定义的成员类型是ElementType数组，Target中可以传入多个参数</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">public @interface Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数的类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//使用的jdk8中的ElementType 在8之前没有TYPE_PARAMETER和TYPE_USE两个参数值</span><br><span class="line"></span><br><span class="line">ANNOTATION_TYPE,//注释类声明</span><br><span class="line">CONSTRUCTOR,//构造方法声明</span><br><span class="line">FIELD,//字段声明</span><br><span class="line">LOCAL_VARIABLE,//局部变量声</span><br><span class="line">METHOD,//方法声明</span><br><span class="line">PACKAGE,//包声明</span><br><span class="line">PARAMETER,//参数声明</span><br><span class="line">TYPE,//类、接口声明</span><br><span class="line">TYPE_PARAMETER,//类型参数声明</span><br><span class="line">TYPE_USE;//没搞懂这个，官方API中给出的注释是Use of a type</span><br></pre></td></tr></table></figure><ul><li>示例：<code>@Target({METHOD,TYPE})</code>表示可以作用于方法、类、接口等</li></ul><h4 id="Retention注解"><a href="#Retention注解" class="headerlink" title="@Retention注解"></a>@Retention注解</h4><ul><li><p>Retention指的是该注解的生命周期</p></li><li><p>参数类型</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CLASS,//只在源码显示，编译时会丢失</span><br><span class="line">RUNTIME,//编译时会记录到class中，运行时忽略</span><br><span class="line">SOURCE;//运行时存在，可以通过反射获取</span><br></pre></td></tr></table></figure><h4 id="Inherited注解"><a href="#Inherited注解" class="headerlink" title="@Inherited注解"></a>@Inherited注解</h4><ul><li><p>Inherited表示允许子类继承</p></li><li><p>属于标识注解</p></li></ul><h4 id="Documented注解"><a href="#Documented注解" class="headerlink" title="@Documented注解"></a>@Documented注解</h4><ul><li><p>生成javadoc时会包含注解的信息</p></li><li><p>属于标识注解</p></li></ul><h3 id="自定义注解用法："><a href="#自定义注解用法：" class="headerlink" title="自定义注解用法："></a>自定义注解用法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//多个成员用法</span><br><span class="line"></span><br><span class="line">@Description(name = &quot;gdy&quot;,gender = &quot;man&quot;,age = 20)</span><br><span class="line">public String getName() &#123;</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br><span class="line">//只有一个成员定义</span><br><span class="line">@Description2(&quot;gdy&quot;)</span><br><span class="line">public String getAge() &#123;</span><br><span class="line">    return age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们就用一个简单的小demo来演示一下注解的具体使用</p><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><h4 id="定义只有一个成员的注解"><a href="#定义只有一个成员的注解" class="headerlink" title="定义只有一个成员的注解"></a>定义只有一个成员的注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">public @interface TestAnn &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//定义了一个接口</span><br><span class="line">public interface Person &#123;</span><br><span class="line">    String name();</span><br><span class="line">    String gender();</span><br><span class="line">    int age();</span><br><span class="line">&#125;</span><br><span class="line">//实现类中使用注解</span><br><span class="line">@TestAnn(&quot;我是一个person实现类&quot;)</span><br><span class="line">public class DuoDuo implements Person &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @TestAnn(&quot;我的名字叫多多&quot;)</span><br><span class="line">    public String name() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String gender() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int age() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在运行时解析注解"><a href="#在运行时解析注解" class="headerlink" title="在运行时解析注解"></a>在运行时解析注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class myClass &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //1、使用类加载器加载类</span><br><span class="line">            Class duo = Class.forName(&quot;com.rxjava.model.DuoDuo&quot;);</span><br><span class="line">            //2、找到类上面的注解 </span><br><span class="line">            boolean isExist = duo.isAnnotationPresent(TestAnn.class);</span><br><span class="line">            if (isExist) &#123;</span><br><span class="line">                //3、获取注解实例，并输出值</span><br><span class="line">                TestAnn t = (TestAnn) duo.getAnnotation(TestAnn.class);</span><br><span class="line">                System.out.println(t.value());</span><br><span class="line">            &#125;</span><br><span class="line">            //4、获取每个方法上的值</span><br><span class="line">            Method[] duoMethods = duo.getMethods();</span><br><span class="line">            for (Method duoM : duoMethods) &#123;</span><br><span class="line">                boolean isMExist = duoM.isAnnotationPresent(TestAnn.class);</span><br><span class="line">                if (isMExist) &#123;</span><br><span class="line">                    TestAnn tm = duoM.getAnnotation(TestAnn.class);</span><br><span class="line">                    System.out.println(tm.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="/2018/11/09/Java/print_out.jpg" alt="输出结果"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本篇文章是根据慕课网java注解完全解析，总结出来的笔记，想更细致的了解注解的使用，可移步到慕课网去观看视频，另外还有一篇大神讲解的深入简出、通俗易懂，也可一并观摩。</p><p><a href="https://www.imooc.com/learn/456" target="_blank" rel="noopener">慕课网篇</a></p><p><a href="https://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener">通俗易懂篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章讲述java中注解的概念和注解的基础用法，文章中举例用到的注解、元注解只是一部分，平时工作中用到过，有错误或新的见解，请指出。&lt;/p
      
    
    </summary>
    
      <category term="java" scheme="https://NicholasYG.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://NicholasYG.github.io/tags/java/"/>
    
      <category term="注解" scheme="https://NicholasYG.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Android微信支付</title>
    <link href="https://NicholasYG.github.io/2018/10/27/Android%E6%94%AF%E4%BB%98/"/>
    <id>https://NicholasYG.github.io/2018/10/27/Android支付/</id>
    <published>2018-10-27T02:29:56.000Z</published>
    <updated>2018-10-27T07:34:24.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集成步骤"><a href="#集成步骤" class="headerlink" title="集成步骤"></a>集成步骤</h2><h3 id="先贴上官方文档的集成步骤"><a href="#先贴上官方文档的集成步骤" class="headerlink" title="先贴上官方文档的集成步骤"></a>先贴上官方文档的集成步骤</h3><p><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419319167&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">资源链接</a><br>微信支付所需要的资源文件（包含支付demo和签名生成工具）</p><p><a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_5" target="_blank" rel="noopener">集成步骤链接</a><br>按照官方文档，一步一步集成下去，你会发现一个接一个-1等着你。</p><h3 id="导入依赖库（jar包）"><a href="#导入依赖库（jar包）" class="headerlink" title="导入依赖库（jar包）"></a>导入依赖库（jar包）</h3><ul><li>导入相关文件，在eclipse上是导入jar包，在AS环境中，可以再build.gradle文件中，添加如下依赖即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">//包含统计功能</span><br><span class="line">   compile &apos;com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+&apos;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">dependencies &#123;</span><br><span class="line">   compile &apos;com.tencent.mm.opensdk:wechat-sdk-android-without-mta:+&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当然也还可以用导入jar包的方式，下载demo文件，找到libammsdk.jar，导入到自己的项目libs文件夹中(解压压缩包，在libs文件夹中找到libammsdk.jar)</li></ul><p><img src="/2018/10/27/Android支付/source_link.jpg" alt="资源下载"></p><p>下载地址同上面的资源链接，之后同步工程，jar包导入工作就算完成了。</p><h3 id="添加WXPayEntryActivity文件（微信结果回调的类）"><a href="#添加WXPayEntryActivity文件（微信结果回调的类）" class="headerlink" title="添加WXPayEntryActivity文件（微信结果回调的类）"></a>添加WXPayEntryActivity文件（微信结果回调的类）</h3><p>WXPayEntryActivity是微信支付结果的回调类，调用微信支付SDK之后返回的结果，都会此类中获取到，根据集成要求，此类必须放在指定的位置。</p><p><img src="/2018/10/27/Android支付/file_catalog.jpg" alt="回调类的位置"></p><p>如上图WXPayEntryActivity必须放在这个路径下面（在Project目录结构下 <code>main</code>–<code>java</code>–<code>自己的包名</code>–<code>wxapi</code>–<code>WXPayEntryActivity</code>），如果集成过微信分享，放置的文件位置是一样的。<br>然后在清单文件(AndroidManifest)中加入WXPayEntryActivity的相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--微信支付--&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.wxapi.WXPayEntryActivity&quot;</span><br><span class="line">    android:exported=&quot;true&quot;</span><br><span class="line">    android:launchMode=&quot;singleTop&quot;</span><br><span class="line">    android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">        &lt;data android:scheme=&quot;you appid&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>看一下里面的内容</p><p><img src="/2018/10/27/Android支付/WXPayEntryActivity.jpg" alt="onCreat内容"></p><p>在onCreat方法中，有一个布局文件，你可以自定义，微信支付调起以后，你想展示怎样的界面，如何告知用户，都可以在WXPayEntryActivity中展示，当然，也可以注释掉，不使用任何布局，获取到支付结果后，做相应的处理就行。<br>下面是获取支付结果的方法：</p><p><img src="/2018/10/27/Android支付/pay_method.jpg" alt="支付结果返回码"></p><p>demo中给出的onResp方法，会将支付结果以弹窗的形式显示出来。当然你可以根据不同的状态码做不同的操作，<br>仅供参考（code 0、支付成功  -1、支付失败  -2、取消支付）</p><p><img src="/2018/10/27/Android支付/code_state.jpg" alt="状态处理"></p><p>你可以根据不同的状态做相应的处理，文档也对三种状态有对应的解释：</p><p><img src="/2018/10/27/Android支付/error_code.jpg" alt="文档code说明"></p><p>其中支付失败，返回-1的场景有很多，后面再详细说明。</p><h3 id="调用微信支付"><a href="#调用微信支付" class="headerlink" title="调用微信支付"></a>调用微信支付</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void toWeChatPay(OrderModel orderModel) &#123;</span><br><span class="line">     IWXAPI wxapi = WXAPIFactory.createWXAPI(this, Const.WECHAT_PAY_APP_ID);    </span><br><span class="line">    if (wxapi.isWXAppInstalled()) &#123;//判断是否安装微信</span><br><span class="line">    wxapi.registerApp(Const.WECHAT_PAY_APP_ID);//把app注册到微信</span><br><span class="line">        //给PayReq赋值</span><br><span class="line">        PayReq req = new PayReq();</span><br><span class="line">        req.appId = Const.WECHAT_PAY_APP_ID;</span><br><span class="line">        req.partnerId = orderModel.partnerId;</span><br><span class="line">        req.prepayId = orderModel.prepayId;</span><br><span class="line">        req.packageValue = orderModel.packageValue;</span><br><span class="line">        req.nonceStr = orderModel.nonceStr;</span><br><span class="line">        req.timeStamp = orderModel.timeStamp;</span><br><span class="line">        req.sign = orderModel.sign;</span><br><span class="line">        //发起请求 调用微信支付</span><br><span class="line">        wxapi.sendReq(req);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ToastUtil.showToast(activity, &quot;请您先安装微信！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时的七个参数，可以查看具体的<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_12" target="_blank" rel="noopener">文档说明</a></p><p><img src="/2018/10/27/Android支付/parameter.jpg" alt="参数"></p><p>这些个参数，可以跟后台沟通，返回给我们使用，当然其中的appid可以定义成静态的全局变量,在使用之前最好做一下非空判断。</p><h3 id="调用返回-1分析"><a href="#调用返回-1分析" class="headerlink" title="调用返回-1分析"></a>调用返回-1分析</h3><p>以上步骤如果你已经全部完成，那么恭喜你集成算是成功了，接下来将是调用迎来的errCode = -1，在文档上，对于-1的解释是这样的：</p><blockquote><p>可能的原因：签名错误、未注册APPID、项目设置APPID不正确、注册的APPID与设置的不匹配、其他异常等</p></blockquote><p>对以上提到的错误原因我们一一分析：</p><h4 id="首先说说签名错误"><a href="#首先说说签名错误" class="headerlink" title="首先说说签名错误"></a>首先说说签名错误</h4><p>签名如何获取？根据文档提供的下载链接，下载签名工具，输入包名，生成app唯一的签名，在文档上有详细的说明，但是要注意生成的签名，debug包和release包生成的签名是不一样的，所以在微信开放平台中填写的签名一定要区分，在测试阶段使用的是debug包生成的签名，上线使用的必须是release包生成的签名，一句话，应用包和签名一致，如果签名不一致，就会造成支付失败，errCode返回-1的情况。如果集成的有微信分享，可以用微信分享验证签名是否正确，如果同一签名下，微信分享可以分享成功，那么微信支付的签名一定是对的，返回-1就从其他方面找原因。</p><h4 id="APPID错误"><a href="#APPID错误" class="headerlink" title="APPID错误"></a>APPID错误</h4><p> APPID是微信开放平台给应用分配的，从上面复制就行，可以把APPID放在本地（一般不会变的），在AndroidManifast中、调用微信支付、WXPayEntryActivity等都会用到APPID。</p><h4 id="参数错误"><a href="#参数错误" class="headerlink" title="参数错误"></a>参数错误</h4><p>APPID和签名都正确的情况，再去调用微信支付。可能会出现这样的情况：如果微信未登录的情况下，会把微信调起来，在登录的情况下，返回值还是-1，这时候就要考虑参数的问题了，从demo里面拿过来的appid和一系列参数，放到自己的项目里面是不行的，参数要使用自己的appid对应生成的参数才可以，调用起微信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;集成步骤&quot;&gt;&lt;a href=&quot;#集成步骤&quot; class=&quot;headerlink&quot; title=&quot;集成步骤&quot;&gt;&lt;/a&gt;集成步骤&lt;/h2&gt;&lt;h3 id=&quot;先贴上官方文档的集成步骤&quot;&gt;&lt;a href=&quot;#先贴上官方文档的集成步骤&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Android" scheme="https://NicholasYG.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://NicholasYG.github.io/tags/Android/"/>
    
      <category term="支付" scheme="https://NicholasYG.github.io/tags/%E6%94%AF%E4%BB%98/"/>
    
      <category term="微信" scheme="https://NicholasYG.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用AS上传lib(module)包到Nexus私服（3.x）</title>
    <link href="https://NicholasYG.github.io/2018/10/16/Nexus%E7%A7%81%E6%9C%8D%E4%B8%8A%E4%BC%A0/"/>
    <id>https://NicholasYG.github.io/2018/10/16/Nexus私服上传/</id>
    <published>2018-10-16T11:41:02.000Z</published>
    <updated>2018-10-16T12:12:19.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="本篇文章要解决的问题如下"><a href="#本篇文章要解决的问题如下" class="headerlink" title="本篇文章要解决的问题如下"></a>本篇文章要解决的问题如下</h3><ul><li>搭建nexus私服</li><li>在nexus上创建仓库</li><li>配置grald文件，上传lib(module)包</li><li>在AS中使用</li></ul><p>本篇文章是基于Mac系统的基础上，搭建nexus；和windows系统搭建稍有差异。另本版本是基于nexus3.13.0版本，请知晓。</p><h2 id="nexus服务器搭建"><a href="#nexus服务器搭建" class="headerlink" title="nexus服务器搭建"></a>nexus服务器搭建</h2><h3 id="java环境"><a href="#java环境" class="headerlink" title="java环境"></a>java环境</h3><p>此版本的nexus是基于java，要求java JRE的版本不低于1.8.0，所以安装之前，先检测自己本地安装的JRE版本是否符合要求。</p><ul><li>检测当前java版本命令，在终端输入<br><code>java -version</code></li></ul><p><img src="/2018/10/16/Nexus私服上传/jave_version.jpg" alt="版本图片"><br>如上图，版本在1.8以上就可以下载nexus啦。</p><h3 id="下载nexus"><a href="#下载nexus" class="headerlink" title="下载nexus"></a>下载nexus</h3><p>可以在<a href="https://www.sonatype.com/download-oss-sonatype" target="_blank" rel="noopener">官方网站</a>下载最新版本的nexus，选择OS X版本</p><p><img src="/2018/10/16/Nexus私服上传/download_nexus.jpg" alt="下载截图"></p><p>下载完成后，打开解压包，会看到如下的目录</p><p><img src="/2018/10/16/Nexus私服上传/nexus_bin.jpg" alt="nexus文件目录"></p><p>接着在终端进入到bin目录下，输入命令 <code>nexus start</code> 看到 Starting nexus 字样就说明启动成功了</p><p><img src="/2018/10/16/Nexus私服上传/nexus_start.jpg" alt="开启nexus"></p><h2 id="在nexus上创建私有仓库"><a href="#在nexus上创建私有仓库" class="headerlink" title="在nexus上创建私有仓库"></a>在nexus上创建私有仓库</h2><h3 id="访问nexus和界面介绍"><a href="#访问nexus和界面介绍" class="headerlink" title="访问nexus和界面介绍"></a>访问nexus和界面介绍</h3><p>在本地浏览器输入<code>http://localhost:8081/</code> 跳转到nexus首页</p><p><img src="/2018/10/16/Nexus私服上传/nexus_index_page.jpg" alt="nexus首页"></p><p>在<code>Sign in</code>登录入口登录账号，nexus提供了一个公用账号 账号：admin 密码：admin123,登录上之后点击下图中第一步进入到设置界面，如下：</p><p><img src="/2018/10/16/Nexus私服上传/repository_page.jpg" alt="nexus首页"></p><p>点击第二步跳转到创建仓库界面。</p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>跳转到创建仓库界面，如下图</p><p><img src="/2018/10/16/Nexus私服上传/repository_list_default.jpg" alt="仓库列表界面"></p><p>可以看到nexus为我们创建了默认的仓库，在type列有<code>proxy、group、hosted</code>等类型，这三种类型都有什么作用呢？且看下面的解释：</p><ul><li>proxy（远程代理仓库）</li></ul><blockquote><p>这种类型的仓库，可以设置一个远程仓库的链接。当用户向 proxy 类型仓库请求下载一个依赖构件时，就会先在自己的库里查找，如果找不到的话，就会从设置的远程仓库下载到自己的库里，然后返回给用户，相当于起到一个中转的作用。例如 maven-central 用来存储从 Maven 中央仓库下载过的构件。</p></blockquote><ul><li>group （聚合仓库）</li></ul><blockquote><p>在 Maven 里没有这个概念，是 Nexus 特有的。目的是将多个仓库聚合，对用户暴露统一的地址，这样用户就不需要配置多个地址，只要统一配置 group 的地址就可以了。group 仓库的聚合成员可以在仓库设置中添加和移除。例如 maven-public 是一个 group 类型的仓库，通过引用这个地址，可以访问组内成员仓库的所有构件。</p></blockquote><ul><li>hosted（宿主仓库）</li></ul><blockquote><p>我们自己的构件，上传的就是这样的仓库。目前 maven-releases 和 maven-snapshots 是 hosted 类型的仓库。我们可以上传到这两个仓库，也可以自己创建 hosted 仓库。</p></blockquote><p>接着点击<code>Create Repositories</code>按钮，跳转到选择仓库界面，选择<code>maven2（hosted）</code>仓库</p><p><img src="/2018/10/16/Nexus私服上传/select_page.jpg" alt="选择仓库界面"></p><p>接下来是仓库的配置，可以根据自己的需求来修改</p><p><img src="/2018/10/16/Nexus私服上传/repository_detail.jpg" alt="配置详情页"></p><p>对于上面Maven2中Version policy的配置，官方是这样解释的:</p><ul><li>Release</li></ul><blockquote><p>可以将Maven存储库配置为适用于发布版本策略的发布组件。中央存储库使用发布版本策略</p></blockquote><ul><li>Snapshot</li></ul><blockquote><p>持续开发通常使用快照版本策略支持的快照版本执行。这些版本值必须以POM文件中的-SNAPSHOT结尾。这允许重复上传，其中实际使用的数字由日期/时间戳和枚举数组成，而且检索仍然可以使用-SNAPSHOT版本字符串。存储库管理器和客户机工具管理从快照版本到时间戳值的转换的元数据文件。</p></blockquote><ul><li>Mixed</li></ul><blockquote><p>混合版本策略允许您在一个存储库中支持这两种方法。</p></blockquote><p>附上<a href="https://help.sonatype.com/repomanager3/maven-repositories" target="_blank" rel="noopener">官方文档</a>，可以去看其他的配置解释。</p><p>点击保存，仓库就创建好了。回到首页，选择Browse，就可以看到我们刚才创建的仓库</p><p><img src="/2018/10/16/Nexus私服上传/new_repository.jpg" alt="新创建仓库"></p><p>点击列表中的<code>Copy</code>按钮，从弹框中获取到仓库地址，暂时保存待会儿会用到。</p><h2 id="创建lib（module）包，通过gradle上传"><a href="#创建lib（module）包，通过gradle上传" class="headerlink" title="创建lib（module）包，通过gradle上传"></a>创建lib（module）包，通过gradle上传</h2><h3 id="新建lib（module）包"><a href="#新建lib（module）包" class="headerlink" title="新建lib（module）包"></a>新建lib（module）包</h3><p>打开Android Studio在项目中创建lib包，选择Android Library；具体步骤如下：<br>在项目上右键，选择<code>new</code> –&gt; <code>Module</code> –&gt; <code>选择Android library</code></p><p><img src="/2018/10/16/Nexus私服上传/new_lib.jpg" alt="新建lib"></p><p>接着next下一步就可以了</p><p><img src="/2018/10/16/Nexus私服上传/select_android.jpg" alt="选择Android类型"></p><p>在lib（module）中写自己想要上传的内容，简单写一个类一个方法可以在后面调用就可以。</p><h3 id="配置gradle文件"><a href="#配置gradle文件" class="headerlink" title="配置gradle文件"></a>配置gradle文件</h3><p>内容补充完成后，需要在自己创建的lib（module）包的<code>build.gradle</code>文件中添加上传的代码，代码内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;maven&apos;</span><br><span class="line">task androidSourcesJar(type: Jar) &#123;</span><br><span class="line">    classifier = &apos;sources&apos;</span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">&#125;</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives androidSourcesJar</span><br><span class="line">&#125;</span><br><span class="line">afterEvaluate &#123; project -&gt;</span><br><span class="line">    uploadArchives &#123;</span><br><span class="line">        repositories &#123;</span><br><span class="line">            mavenDeployer &#123;</span><br><span class="line">                    //远程仓库的地址</span><br><span class="line">                repository(url: &quot;http://localhost:8081/repository/TestRepositoris/&quot;) &#123;</span><br><span class="line">                    //nexus登录的用户名和密码</span><br><span class="line">                    authentication(userName: &quot;admin&quot;, password: &quot;admin123&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                pom.project &#123;</span><br><span class="line">                    /**</span><br><span class="line">                     * 这三个字段是组成后续引用的关键，举例：</span><br><span class="line">                     * 之后在项目中会这样引用</span><br><span class="line">                     * com.xxx:testlibrary:1.0.0</span><br><span class="line">                     */</span><br><span class="line">                    groupId &apos;com.xxx&apos;</span><br><span class="line">                    artifactId &apos;testlibrary&apos;</span><br><span class="line">                    version &apos;1.0.0&apos;//版本号 </span><br><span class="line">                    packaging &apos;aar&apos;//打包的格式</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为方便配置也可以将上述代码新建一个gradle上传文件，在lib的build.gradle文件中来引用，具体操作：在lib(module)包上右键 –&gt; <code>New</code> –&gt; <code>File</code>；</p><p><img src="/2018/10/16/Nexus私服上传/new_gradle.jpg" alt="创建gradle文件"></p><p>之后创建.gradle为后缀名的文件</p><p><img src="/2018/10/16/Nexus私服上传/file_gradle.jpg" alt="gradle文件"></p><p>将上面配置代码复制进去,接着打开lib(module)包的<code>build.gradle</code>文件，引入新建的gradle文件，在上面添加<code>apply from: &#39;./upload.gradle&#39;</code> upload.gradle指的就是你创建的gradle文件，引入到build.gradle文件中使用</p><p><img src="/2018/10/16/Nexus私服上传/quote_file.jpg" alt="引入文件"></p><p>最后还需要在项目根目录的build.gradle文件中添加我们的仓库地址</p><p><img src="/2018/10/16/Nexus私服上传/project_gradle.jpg" alt="项目的gradle"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:3.0.1&apos;</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line">        //对maven插件进行修改可以兼容android</span><br><span class="line">        classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.5&apos;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven&#123;//仓库的地址</span><br><span class="line">            url &apos;http://localhost:8081/repository/TestRepositoris/&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步一下文件，AS会把我们的lib(module)生成要上传的文件。</p><h3 id="上传lib-module-包到nexus私服"><a href="#上传lib-module-包到nexus私服" class="headerlink" title="上传lib(module)包到nexus私服"></a>上传lib(module)包到nexus私服</h3><p>在AS编辑器的右侧工具栏，点击Gradle –&gt; 选择自己的项目 –&gt; 点击upload文件 –&gt; 双击uploadArchives</p><p><img src="/2018/10/16/Nexus私服上传/upload_lib.jpg" alt="上传lib包"></p><p>等待上传完成之后，就可以去私服上查看啦。点击自己创建的仓库查看：</p><p><img src="/2018/10/16/Nexus私服上传/upload_list_brower.jpg" alt="浏览器列表"></p><p>切换视图，网页版的展示</p><p><img src="/2018/10/16/Nexus私服上传/upload_list_html.jpg" alt="html浏览"></p><p>至此上传部分的工作已经完成；接下来就是在项目使用了。</p><h2 id="在AS中使用仓库中的lib"><a href="#在AS中使用仓库中的lib" class="headerlink" title="在AS中使用仓库中的lib"></a>在AS中使用仓库中的lib</h2><h3 id="在项目中引用"><a href="#在项目中引用" class="headerlink" title="在项目中引用"></a>在项目中引用</h3><ul><li>复制仓库的地址，放置在你想要引用项目的根目录的<code>build.gradle</code>中。注意：这里的项目是放置另外一个项目中，和lib包不是在同一个项目</li></ul><p><img src="/2018/10/16/Nexus私服上传/quote_project_gradle.jpg" alt="新项目中的引用"></p><ul><li>然后在app的<code>build.gradle</code>中加入<code>compile &#39;com.test:testlibrary:1.0.0&#39;</code></li></ul><p><img src="/2018/10/16/Nexus私服上传/quote_app_grade.jpg" alt="app的gradle中"></p><p>同步一下，就可以在代码中愉快的使用了，我是在lib包中放了一些关于缓存的代码，在项目中使用：</p><p><img src="/2018/10/16/Nexus私服上传/user_code.jpg" alt="代码中使用"></p><p>点击进去查看ACache文件，可以看到路径</p><p><img src="/2018/10/16/Nexus私服上传/lib_path.jpg" alt="路径"></p><p>到这里整个建库、上传、使用整个流程都完成了。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>第一次写公开式博客，历时2天，中间写写停停，还好最后算是勉强完成；之前自己有想记录的东西，都是以笔记的形式记录下来，很是粗糙，自己能看懂就行，不够细致，这篇写下来感觉真的很能加强知识点深度，强迫自己看了平时不愿看的英文文档，还写了迟迟不肯动手的demo，当写完的那一刻有一种酣畅淋漓的舒爽。第一次写还有许多不足的地方，会不断去完善，去修正编写的方式。坚持写下去，做一个深入简出的讲述者。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>写这篇博客参考了几位前辈的博客，在这里贴上链接，他们写的都很好，很值得借鉴和学习。</p><p><a href="https://blog.csdn.net/qq_32452623/article/details/79385595" target="_blank" rel="noopener">Android-Nexus 搭建自己的 Maven 仓库 &amp; Gradle 上传依赖包</a></p><p><a href="https://www.cnblogs.com/whoislcj/p/6490120.html" target="_blank" rel="noopener">Android业务组件化之Gradle和Sonatype Nexus搭建私有maven仓库</a></p><p><a href="https://www.jianshu.com/p/348cdc711c00" target="_blank" rel="noopener">Android依赖管理与私服搭建</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;本篇文章要解决的问题如下&quot;&gt;&lt;a href=&quot;#本篇文章要解决的问题如下&quot; class=&quot;headerlink&quot; title=&quot;本
      
    
    </summary>
    
      <category term="java" scheme="https://NicholasYG.github.io/categories/java/"/>
    
    
      <category term="Android" scheme="https://NicholasYG.github.io/tags/Android/"/>
    
      <category term="java" scheme="https://NicholasYG.github.io/tags/java/"/>
    
      <category term="nexus" scheme="https://NicholasYG.github.io/tags/nexus/"/>
    
  </entry>
  
</feed>
